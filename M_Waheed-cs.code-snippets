{
	// Place your global snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"all": {
		"scope": "cpp",
		"prefix": "all",
		"body": [
			"$1.begin(), $1.end()$2"
		],
		"description": "all"
	},
	"sort": {
		"scope": "cpp",
		"prefix": "sort",
		"body": [
			"sort($1.begin(), $1.end());$2"
		],
		"description": "sort"
	},
	"reverse": {
		"scope": "cpp",
		"prefix": "reverse",
		"body": [
			"reverse($1.begin(), $1.end());$2"
		],
		"description": "reverse"
	},
	"rsort": {
		"scope": "cpp",
		"prefix": "rsort",
		"body": [
			"sort($1.rbegin(), $1.rend());$2"
		],
		"description": "rsort"
	},
	"vin": {
		"scope": "cpp",
		"prefix": "vin",
		"body": [
			"int n;",
			"cin >> n;",
			"",
			"vector<long long> v(n);",
			"for (int i = 0; i < n; i++) {",
			"	cin >> v[i];",
			"}"
		],
		"description": "vin"
	},
	"out": {
		"scope": "cpp",
		"prefix": "out",
		"body": [
			"for (auto it : $1) {",
			"	cout << it << \" \";",
			"}",
			"cout << '\\n';"
		],
		"description": "out"
	},
	"2din": {
		"scope": "cpp",
		"prefix": "2din",
		"body": [
			"int n, m;",
			"cin >> n >> m;",
			"",
			"vector<vector<$1>> v(n + 2, vector<$1>(m + 2));",
			"for (int i = 1; i <= n; i++) {",
			"\tfor (int j = 1; j <= m; j++) {",
			"\t\tcin >> v[i][j];",
			"\t}",
			"}"
		],
		"description": "2din"
	},
	"2dout": {
		"scope": "cpp",
		"prefix": "2dout",
		"body": [
			"for (int i = 1; i <= n; i++) {",
			"\tfor (int j = 1; j <= m; j++) {",
			"\t\tcout << v[i][j] << \" \";",
			"\t}",
			"\tcout << \"\\n\";",
			"}"
		],
		"description": "2dout"
	},
	"stin": {
		"scope": "cpp",
		"prefix": "stin",
		"body": [
			"int n;",
			"string s;",
			"cin >> n >> s;",
			"for (int i = 0; i < s.size(); i++) {",
			"}"
		],
		"description": "stin"
	},
	"yes": {
		"scope": "cpp",
		"prefix": "yes",
		"body": [
			"#define yes cout << \"YES\"",
			"#define no cout << \"NO\""
		],
		"description": "yes"
	},
	"mod1": {
		"scope": "cpp",
		"prefix": "mod1",
		"body": [
			"int mod = 1e9 + 7;"
		],
		"description": "mod"
	},
	"mod2": {
		"scope": "cpp",
		"prefix": "mod2",
		"body": [
			"int mod = (119 << 23) + 1;"
		],
		"description": "mod"
	},
	"divisors": {
		"scope": "cpp",
		"prefix": "divisors",
		"body": [
			"template <class M>",
			"vector<M> divisors(M n) {",
			"    vector<M> ret;",
			"    for (long long i = 1; i <= n / i; i++) {",
			"        if (n % i == 0) {",
			"            ret.push_back(i);",
			"            if (i * i != n) {",
			"                ret.push_back(n / i);",
			"            }",
			"        }",
			"    }",
			"    return ret;",
			"}"
		],
		"description": "divisors"
	},
	"prime_factors": {
		"scope": "cpp",
		"prefix": "prime_factors",
		"body": [
			"template <class M>",
			"vector<M> prime_factors(M n) {",
			"    vector<M> ret;",
			"    for (long long i = 2; i <= n / i; i++) {",
			"        while (n % i == 0) {",
			"            n /= i;",
			"            ret.push_back(i);",
			"        }",
			"    }",
			"    if (n > 1) {",
			"        ret.push_back(n);",
			"    }",
			"    return ret;",
			"}"
		],
		"description": ""
	},
	"is_prime": {
		"scope": "cpp",
		"prefix": "is_prime",
		"body": [
			"bool is_prime(long long n) {",
			"    if (n < 2) {",
			"        return 0;",
			"    }",
			"    for (long long i = 2; i <= n / i; i++) {",
			"        if (n % i == 0) {",
			"            return 0;",
			"        }",
			"    }",
			"    return 1;",
			"}"
		],
		"description": ""
	},
	"binarymx": {
		"scope": "cpp",
		"prefix": "binarymx",
		"body": [
			"auto valid = [&](long long mid) {",
			"};",
            "",
			"long long lo = $1, hi = $2, ans = -1;",
			"while (lo <= hi) { // 111000",
			"    long long mid = (lo + hi) / 2;",
			"    if (valid(mid)) {",
			"        lo = mid + 1;",
			"        ans = mid;",
			"    }",
			"    else {",
			"        hi = mid - 1;",
			"    }",
			"}"
		],
		"description": ""
	},
	"binarymn": {
		"scope": "cpp",
		"prefix": "binarymn",
		"body": [
			"auto valid = [&](long long mid) {",
			"};",
            "",
			"long long lo = $1, hi = $2, ans = -1;",
			"while (lo <= hi) { // 000111",
			"    long long mid = (lo + hi) / 2;",
			"    if (valid(mid)) {",
			"        hi = mid - 1;",
			"        ans = mid;",
			"    }",
			"    else {",
			"        lo = mid + 1;",
			"    }",
			"}"
		],
		"description": ""
	},
	"isoverflow": {
		"scope": "cpp",
		"prefix": "isoverflow",
		"body": [
			"bool isOverFlow(long long a, long long b) {",
			"    return log(a) + log(b) > log(3e18);",
			"}"
		],
		"description": ""
	},
	"ceil": {
		"scope": "cpp",
		"prefix": "ceil",
		"body": [
			"long long ceil(long long a, long long b) {",
			"    return (a + b - 1) / b;",
			"}"
		],
		"description": ""
	},
	"lis": {
		"scope": "cpp",
		"prefix": "lis",
		"body": [
			"long long lengthOfLIS(vector<long long> &nums) {",
			"    long long n = nums.size();",
			"    vector<long long> ans;",
			"    ans.push_back(nums[0]);",
			"    for (long long i = 1; i < n; i++) {",
			"        if (nums[i] > ans.back()) {",
			"            ans.push_back(nums[i]);",
			"        }",
			"        else {",
			"            long long low = lower_bound(ans.begin(), ans.end(), nums[i]) - ans.begin();",
			"            ans[low] = nums[i];",
			"        }",
			"    }",
			"    return ans.size();",
			"}"
		],
		"description": ""
	},
	"rev2d": {
		"scope": "cpp",
		"prefix": "rev2d",
		"body": [
			"vector<vector<$1>> rev(vector<vector<$1>> v)",
			"{",
			"    vector<vector<$1>> ret(v[0].size(), vector<$1>(v.size()));",
			"    for (int i = 0; i < v[0].size(); i++) {",
			"        for (int j = 0; j < v.size(); j++) {",
			"            ret[i][j] = v[j][i];",
			"        }",
			"    }",
			"    return ret;",
			"}"
		],
		"description": ""
	},
	"sq": {
		"scope": "cpp",
		"prefix": "sq",
		"body": [
			"long long sq(long long n) {",
			"    long long l = 0, r = 3e9;",
			"    while (l <= r) {",
			"        long long mid = (l + r) / 2;",
			"        if (mid * mid <= n)",
			"            l = mid + 1;",
			"        else",
			"            r = mid - 1;",
			"    }",
			"    return r;",
			"}"
		],
		"description": ""
	},
	"kthbit": {
		"scope": "cpp",
		"prefix": "kthbit",
		"body": [
			"long long kthbit(long long n, long long k) {",
			"    return !!(n & (1LL << k));",
			"}"
		],
		"description": ""
	},
	"pref": {
		"scope": "cpp",
		"prefix": "pref",
		"body": [
			"vector<long long> pref(vector<long long> v) {",
			"    partial_sum(v.begin(), v.end(), v.begin());",
			"    return v;",
			"}"
		],
		"description": ""
	},
	"fix": {
		"scope": "cpp",
		"prefix": "fix",
		"body": [
			"long long fix(long long n, long long mod) {",
			"    return (n % mod + mod) % mod;",
			"}"
		],
		"description": ""
	},
	"mint": {
	"scope": "cpp",
	"prefix": "mint",
	"body": [
			"template <typename T>",
			"T inverse(T a, T m)",
			"{",
			"    T u = 0, v = 1;",
			"    while (a != 0)",
			"    {",
			"        T t = m / a;",
			"        m -= t * a;",
			"        swap(a, m);",
			"        u -= t * v;",
			"        swap(u, v);",
			"    }",
			"    assert(m == 1);",
			"    return u;",
			"}",
			"",
			"template <typename T>",
			"class Modular",
			"{",
			"public:",
			"    using Type = typename decay<decltype(T::value)>::type;",
			"",
			"    constexpr Modular() : value() {}",
			"    template <typename U>",
			"    Modular(const U &x)",
			"    {",
			"        value = normalize(x);",
			"    }",
			"",
			"    template <typename U>",
			"    static Type normalize(const U &x)",
			"    {",
			"        Type v;",
			"        if (-mod() <= x && x < mod())",
			"            v = static_cast<Type>(x);",
			"        else",
			"            v = static_cast<Type>(x % mod());",
			"        if (v < 0)",
			"            v += mod();",
			"        return v;",
			"    }",
			"",
			"    const Type &operator()() const { return value; }",
			"    template <typename U>",
			"    explicit operator U() const { return static_cast<U>(value); }",
			"    constexpr static Type mod() { return T::value; }",
			"",
			"    Modular &operator+=(const Modular &other)",
			"    {",
			"        if ((value += other.value) >= mod())",
			"            value -= mod();",
			"        return *this;",
			"    }",
			"    Modular &operator-=(const Modular &other)",
			"    {",
			"        if ((value -= other.value) < 0)",
			"            value += mod();",
			"        return *this;",
			"    }",
			"    template <typename U>",
			"    Modular &operator+=(const U &other) { return *this += Modular(other); }",
			"    template <typename U>",
			"    Modular &operator-=(const U &other) { return *this -= Modular(other); }",
			"    Modular &operator++() { return *this += 1; }",
			"    Modular &operator--() { return *this -= 1; }",
			"    Modular operator++(int)",
			"    {",
			"        Modular result(*this);",
			"        *this += 1;",
			"        return result;",
			"    }",
			"    Modular operator--(int)",
			"    {",
			"        Modular result(*this);",
			"        *this -= 1;",
			"        return result;",
			"    }",
			"    Modular operator-() const { return Modular(-value); }",
			"",
			"    template <typename U = T>",
			"    typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type &operator*=(const Modular &rhs)",
			"    {",
			"#ifdef _WIN32",
			"        uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);",
			"        uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;",
			"        asm(",
			"            \"divl %4; \\n\\t\"",
			"            : \"=a\"(d), \"=d\"(m)",
			"            : \"d\"(xh), \"a\"(xl), \"r\"(mod()));",
			"        value = m;",
			"#else",
			"        value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));",
			"#endif",
			"        return *this;",
			"    }",
			"    template <typename U = T>",
			"    typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type &operator*=(const Modular &rhs)",
			"    {",
			"        long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());",
			"        value = normalize(value * rhs.value - q * mod());",
			"        return *this;",
			"    }",
			"    template <typename U = T>",
			"    typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type &operator*=(const Modular &rhs)",
			"    {",
			"        value = normalize(value * rhs.value);",
			"        return *this;",
			"    }",
			"",
			"    Modular &operator/=(const Modular &other) { return *this *= Modular(inverse(other.value, mod())); }",
			"",
			"    friend const Type &abs(const Modular &x) { return x.value; }",
			"",
			"    template <typename U>",
			"    friend bool operator==(const Modular<U> &lhs, const Modular<U> &rhs);",
			"",
			"    template <typename U>",
			"    friend bool operator<(const Modular<U> &lhs, const Modular<U> &rhs);",
			"",
			"    template <typename V, typename U>",
			"    friend V &operator>>(V &stream, Modular<U> &number);",
			"",
			"private:",
			"    Type value;",
			"};",
			"",
			"template <typename T>",
			"bool operator==(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value == rhs.value; }",
			"template <typename T, typename U>",
			"bool operator==(const Modular<T> &lhs, U rhs) { return lhs == Modular<T>(rhs); }",
			"template <typename T, typename U>",
			"bool operator==(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) == rhs; }",
			"",
			"template <typename T>",
			"bool operator!=(const Modular<T> &lhs, const Modular<T> &rhs) { return !(lhs == rhs); }",
			"template <typename T, typename U>",
			"bool operator!=(const Modular<T> &lhs, U rhs) { return !(lhs == rhs); }",
			"template <typename T, typename U>",
			"bool operator!=(U lhs, const Modular<T> &rhs) { return !(lhs == rhs); }",
			"",
			"template <typename T>",
			"bool operator<(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value < rhs.value; }",
			"",
			"template <typename T>",
			"Modular<T> operator+(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }",
			"template <typename T, typename U>",
			"Modular<T> operator+(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) += rhs; }",
			"template <typename T, typename U>",
			"Modular<T> operator+(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }",
			"",
			"template <typename T>",
			"Modular<T> operator-(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }",
			"template <typename T, typename U>",
			"Modular<T> operator-(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) -= rhs; }",
			"template <typename T, typename U>",
			"Modular<T> operator-(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }",
			"",
			"template <typename T>",
			"Modular<T> operator*(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }",
			"template <typename T, typename U>",
			"Modular<T> operator*(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) *= rhs; }",
			"template <typename T, typename U>",
			"Modular<T> operator*(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }",
			"",
			"template <typename T>",
			"Modular<T> operator/(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }",
			"template <typename T, typename U>",
			"Modular<T> operator/(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) /= rhs; }",
			"template <typename T, typename U>",
			"Modular<T> operator/(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }",
			"",
			"template <typename T, typename U>",
			"Modular<T> power(const Modular<T> &a, const U &b)",
			"{",
			"    assert(b >= 0);",
			"    Modular<T> x = a, res = 1;",
			"    U p = b;",
			"    while (p > 0)",
			"    {",
			"        if (p & 1)",
			"            res *= x;",
			"        x *= x;",
			"        p >>= 1;",
			"    }",
			"    return res;",
			"}",
			"",
			"template <typename T>",
			"bool IsZero(const Modular<T> &number)",
			"{",
			"    return number() == 0;",
			"}",
			"",
			"template <typename T>",
			"string to_string(const Modular<T> &number)",
			"{",
			"    return to_string(number());",
			"}",
			"",
			"// U == std::ostream? but done this way because of fastoutput",
			"template <typename U, typename T>",
			"U &operator<<(U &stream, const Modular<T> &number)",
			"{",
			"    return stream << number();",
			"}",
			"",
			"// U == std::istream? but done this way because of fastinput",
			"template <typename U, typename T>",
			"U &operator>>(U &stream, Modular<T> &number)",
			"{",
			"    typename common_type<typename Modular<T>::Type, long long>::type x;",
			"    stream >> x;",
			"    number.value = Modular<T>::normalize(x);",
			"    return stream;",
			"}",
			"",
			"/*",
			"using ModType = int;",
			"",
			"struct VarMod { static ModType value; };",
			"ModType VarMod::value;",
			"ModType& md = VarMod::value;",
			"using Mint = Modular<VarMod>;",
			"*/",
			"",
			"constexpr int md = 998244353;",
			"using Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;",
			"",
			"/*vector<Mint> fact(1, 1);",
			"vector<Mint> inv_fact(1, 1);",
			"",
			"Mint C(int n, int k) {",
			"  if (k < 0 || k > n) {",
			"    return 0;",
			"  }",
			"  while ((int) fact.size() < n + 1) {",
			"    fact.push_back(fact.back() * (int) fact.size());",
			"    inv_fact.push_back(1 / fact.back());",
			"  }",
			"  return fact[n] * inv_fact[k] * inv_fact[n - k];",
			"}*/",


	],
	"description": ""
	},
    "matrixmult":{
        "scope": "cpp",
	    "prefix": "matrixmult",
	    "body": [
           "vector<vector<long long>> mult(const vector<vector<long long>> &a, const vector<vector<long long>> &b) {",
           "    vector<vector<long long>> ret(a.size(), vector<long long>(b[0].size(), 0));",
           "    for (long long i = 0; i < a.size(); i++) {",
           "        for (long long j = 0; j < b[0].size(); j++) {",
           "            for (long long o = 0; o < b.size(); o++)",
           "                ret[i][j] += (a[i][o] * b[o][j]);",
           "        }",
           "    }",
           "    return ret;",
           "}",
	    ],
        "description" : ""
    },
    "kadane":{
        "scope": "cpp",
	    "prefix": "kadane",
	    "body": [
           "long long kadane(vector<long long> v, long long &l, long long &r) {",
           "    long long sum = 0, temp = 0, start = 0;",
           "    for (ll i = 0; i < v.size(); i++) {",
           "        temp += v[i];",
           "        if (sum < temp) {",
           "            sum = temp;",
           "            l = start;",
           "            r = i;",
           "        }",
           "        if (temp < 0) {",
           "            temp = 0;",
           "            start = i + 1;",
           "        }",
           "    }",
           "    return sum;",
           "}",
	    ],
        "description" : ""
    },
    "phi":{
        "scope": "cpp",
	    "prefix": "phi",
	    "body": [
           "long long phi(long long n) { // n * (1 - 1/p)",
           "    long long ret = n;",
           "    for (long long i = 2; i <= n / i; i++) {",
           "        if (n % i == 0) {",
           "            while (n % i == 0)",
           "                n /= i;",
           "            ret -= ret / i;",
           "        }",
           "    }",
           "    if (n > 1)",
           "        ret -= ret / n;",
           "    return ret;",
           "}",
	    ],
        "description" : ""
    },
    "rope":{
        "scope": "cpp",
	    "prefix": "rope",
	    "body": [
           "#include <ext/rope>",
           "using namespace __gnu_cxx;",
	    ],
        "description" : ""
    },
    "mem":{
        "scope": "cpp",
	    "prefix": "mem",
	    "body": [
           "memset(dp, -1, sizeof dp);",
	    ],
        "description" : ""
    },
    "point":{
        "scope": "cpp",
	    "prefix": "point",
	    "body": [
           "template <typename T>",
           "struct TPoint",
           "{",
           "    T x;",
           "    T y;",
           "    int id;",
           "",
           "    TPoint() : x(0), y(0), id(-1) {}",
           "    TPoint(const T &x_, const T &y_) : x(x_), y(y_), id(-1) {}",
           "    TPoint(const T &x_, const T &y_, int id_) : x(x_), y(y_), id(id_) {}",
           "",
           "    static constexpr T eps = static_cast<T>(1e-9);",
           "",
           "    inline TPoint operator+(const TPoint &rhs) const { return TPoint(x + rhs.x, y + rhs.y); }",
           "    inline TPoint operator-(const TPoint &rhs) const { return TPoint(x - rhs.x, y - rhs.y); }",
           "    inline TPoint operator*(const T &rhs) const { return TPoint(x * rhs, y * rhs); }",
           "    inline TPoint operator/(const T &rhs) const { return TPoint(x / rhs, y / rhs); }",
           "",
           "    friend T smul(const TPoint &a, const TPoint &b)",
           "    {",
           "        return a.x * b.x + a.y * b.y;",
           "    }",
           "",
           "    friend T vmul(const TPoint &a, const TPoint &b)",
           "    {",
           "        return a.x * b.y - a.y * b.x;",
           "    }",
           "",
           "    inline T abs2() const",
           "    {",
           "        return x * x + y * y;",
           "    }",
           "",
           "    inline bool operator<(const TPoint &rhs) const",
           "    {",
           "        return (y < rhs.y || (y == rhs.y && x < rhs.x));",
           "    }",
           "",
           "    inline bool is_upper() const",
           "    {",
           "        return (y > eps || (abs(y) <= eps && x > eps));",
           "    }",
           "",
           "    inline int cmp_polar(const TPoint &rhs) const",
           "    {",
           "        assert(abs(x) > eps || abs(y) > eps);",
           "        assert(abs(rhs.x) > eps || abs(rhs.y) > eps);",
           "        bool a = is_upper();",
           "        bool b = rhs.is_upper();",
           "        if (a != b)",
           "        {",
           "            return (a ? -1 : 1);",
           "        }",
           "        long long v = x * rhs.y - y * rhs.x;",
           "        return (v > eps ? -1 : (v < -eps ? 1 : 0));",
           "    }",
           "};",
           "",
           "using Point = TPoint<long long>;",
           "// using Point = TPoint<long double>;",
           "",
           "template <typename T>",
           "string to_string(const TPoint<T> &p)",
           "{",
           "    return \"(\" + to_string(p.x) + \", \" + to_string(p.y) + \")\";",
           "}",
	    ],
        "description" : ""
    },
    "file":{
        "scope": "cpp",
	    "prefix": "file",
	    "body": [
           "#ifndef ONLINE_JUDGE",
           "    freopen(\"input.txt\", \"r\", stdin);",
           "    freopen(\"output.txt\", \"w\", stdout);",
           "#endif",
	    ],
        "description" : ""
    },
	"linked_list": {
		"prefix": "linked_list",
		"body": [
			"struct node {\r",
			"    int data;\r",
			"    node *next;\r",
			"};\r",
			"class linkedList {\r",
			"private:\r",
			"    node *start;\r",
			"    node *last;\r",
			"\r",
			"public:\r",
			"    linkedList() {\r",
			"        start = NULL;\r",
			"        last = NULL;\r",
			"    }\r",
			"\r",
			"    void addFirst(int item) {\r",
			"        node *n = new node;\r",
			"        n->data = item;\r",
			"        n->next = NULL;\r",
			"\r",
			"        if (start == NULL) {\r",
			"            start = n;\r",
			"            last = n;\r",
			"        }\r",
			"        else {\r",
			"            n->next = start;\r",
			"            start = n;\r",
			"        }\r",
			"    }\r",
			"\r",
			"    void addLast(int item) {\r",
			"        node *n = new node;\r",
			"        n->data = item;\r",
			"        n->next = NULL;\r",
			"\r",
			"        if (start == NULL) {\r",
			"            start = n;\r",
			"            last = n;\r",
			"            return;\r",
			"        }\r",
			"        else {\r",
			"            node *curr = start;\r",
			"            while (curr->next != NULL) {\r",
			"                curr = curr->next;\r",
			"            }\r",
			"            curr->next = n;\r",
			"            last = n;\r",
			"        }\r",
			"    }\r",
			"\r",
			"    void addPosition(int position, int item) {\r",
			"        if (position == 1) {\r",
			"            addFirst(item);\r",
			"            return;\r",
			"        }\r",
			"        position--;\r",
			"        if (start == NULL) {\r",
			"            cout << \"Invalid position.\\n\";\r",
			"            return;\r",
			"        }\r",
			"        node *n = new node;\r",
			"        n->next = NULL;\r",
			"        n->data = item;\r",
			"        node *curr = start;\r",
			"        for (int i = 0; i < position - 1; i++) {\r",
			"            curr = curr->next;\r",
			"            if (curr == NULL) {\r",
			"                cout << \"Invalid Position.\\n\";\r",
			"                return;\r",
			"            }\r",
			"        }\r",
			"        n->next = curr->next;\r",
			"        curr->next = n;\r",
			"        if (n->next == NULL) {\r",
			"            last = n;\r",
			"        }\r",
			"    }\r",
			"\r",
			"    void removeFirst() {\r",
			"        if (start == NULL) {\r",
			"            cout << \"Empty list.\\n\";\r",
			"            return;\r",
			"        }\r",
			"        else {\r",
			"            if (start->next == NULL) {\r",
			"                delete start;\r",
			"                start = NULL;\r",
			"                last = NULL;\r",
			"            }\r",
			"            else {\r",
			"                node *temp = start;\r",
			"                start = start->next;\r",
			"                delete temp;\r",
			"            }\r",
			"        }\r",
			"    }\r",
			"\r",
			"    void removeLast() {\r",
			"        if (start == NULL) {\r",
			"            cout << \"Empty list.\\n\";\r",
			"            return;\r",
			"        }\r",
			"        else {\r",
			"            if (start->next == NULL) {\r",
			"                delete start;\r",
			"                start = NULL;\r",
			"                last = NULL;\r",
			"            }\r",
			"            else {\r",
			"                node *curr = start;\r",
			"                node *temp = last;\r",
			"                while (curr->next != last) {\r",
			"                    curr = curr->next;\r",
			"                }\r",
			"                curr->next = NULL;\r",
			"                last = curr;\r",
			"                delete temp;\r",
			"            }\r",
			"        }\r",
			"    }\r",
			"\r",
			"    int search(int item) {\r",
			"        node *curr = start;\r",
			"        int pos = 0;\r",
			"\r",
			"        while (curr != NULL && curr->data != item) {\r",
			"            curr = curr->next;\r",
			"            pos++;\r",
			"        }\r",
			"\r",
			"        if (curr == NULL) {\r",
			"            pos = -1;\r",
			"        }\r",
			"        return pos;\r",
			"    }\r",
			"\r",
			"    void removeData(int item) {\r",
			"        if (start == NULL) {\r",
			"            cout << \"List is empty.\\n\";\r",
			"            return;\r",
			"        }\r",
			"        else if (start->data == item) {\r",
			"            removeFirst();\r",
			"            return;\r",
			"        }\r",
			"        node *curr = start;\r",
			"        while (curr->next != NULL && curr->data != item) {\r",
			"            curr = curr->next;\r",
			"        }\r",
			"        if (curr->next == NULL) {\r",
			"            cout << \"Data is not found.\\n\";\r",
			"            return;\r",
			"        }\r",
			"        node *n = curr->next;\r",
			"        curr->next = n->next;\r",
			"        delete n;\r",
			"    }\r",
			"\r",
			"    void display() {\r",
			"        node *p = start;\r",
			"        cout << \"The list is: \";\r",
			"        while (p != NULL) {\r",
			"            cout << p->data << \" | \";\r",
			"            p = p->next;\r",
			"        }\r",
			"        cout << \"\\n\";\r",
			"    }\r",
			"};"
		],
		"description": "linked_list"
	}
}
/*

,
"": {
	"scope": "cpp",
	"prefix": "",
	"body": [

	],
	"description": ""
}

*/
