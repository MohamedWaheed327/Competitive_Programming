{
	// Place your global snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"all": {
		"scope": "cpp",
		"prefix": "all",
		"body": [
			"$1.begin(), $1.end()$2"
		],
		"description": "all"
	},
	"sort": {
		"scope": "cpp",
		"prefix": "sort",
		"body": [
			"sort($1.begin(), $1.end());$2"
		],
		"description": "sort"
	},
	"reverse": {
		"scope": "cpp",
		"prefix": "reverse",
		"body": [
			"reverse($1.begin(), $1.end());$2"
		],
		"description": "reverse"
	},
	"rsort": {
		"scope": "cpp",
		"prefix": "rsort",
		"body": [
			"sort($1.rbegin(), $1.rend());$2"
		],
		"description": "rsort"
	},
	"vin": {
		"scope": "cpp",
		"prefix": "vin",
		"body": [
			"ll n;",
			"cin >> n;",
			"vector<ll> v(n);",
			"for (ll i = 0; i < n; i++)",
			"{",
			"\tcin >> v[i];",
			"}"
		],
		"description": "vin"
	},
	"out": {
		"scope": "cpp",
		"prefix": "out",
		"body": [
			"for (auto it : $1)",
			"{",
			"\tcout << it << \" \";",
			"}",
			"cout << '\\n';"
		],
		"description": "out"
	},
	"2din": {
		"scope": "cpp",
		"prefix": "2din",
		"body": [
			"ll n, m;",
			"cin >> n >> m;",
			"vector<vector<$1>> v(n + 2, vector<$1>(m + 2));",
			"for (ll i = 1; i <= n; i++)",
			"{",
			"\tfor (ll j = 1; j <= m; j++)",
			"\t{",
			"\t\tcin >> v[i][j];",
			"\t}",
			"}"
		],
		"description": "2din"
	},
	"2dout": {
		"scope": "cpp",
		"prefix": "2dout",
		"body": [
			"for (ll i = 1; i <= n; i++)",
			"{",
			"\tfor (ll j = 1; j <= m; j++)",
			"\t{",
			"\t\tcout << v[i][j] << \" \";",
			"\t}",
			"\tcout << \"\\n\";",
			"}"
		],
		"description": "2dout"
	},
	"stin": {
		"scope": "cpp",
		"prefix": "stin",
		"body": [
			"ll n;",
			"string s;",
			"cin >> n >> s;",
			"for (ll i = 0; i < s.size(); i++)",
			"{",
			"}"
		],
		"description": "stin"
	},
	"yes": {
		"scope": "cpp",
		"prefix": "yes",
		"body": [
			"#define yes cout << \"YES\";",
			"#define no cout << \"NO\";"
		],
		"description": "yes"
	},
	"mod1": {
		"scope": "cpp",
		"prefix": "mod1",
		"body": [
			"ll mod = 1e9 + 7;"
		],
		"description": "mod"
	},
	"mod2": {
		"scope": "cpp",
		"prefix": "mod2",
		"body": [
			"ll mod = (119 << 23) + 1;"
		],
		"description": "mod"
	},
	"divisors": {
		"scope": "cpp",
		"prefix": "divisors",
		"body": [
			"vector<ll> divisors(ll n)",
			"{",
			"    vector<ll> ret;",
			"    for (ll i = 1; i <= n / i; i++)",
			"    {",
			"        if (n % i == 0)",
			"        {",
			"            ret.push_back(i);",
			"            if (i * i != n)",
			"                ret.push_back(n / i);",
			"        }",
			"    }",
			"    return ret;",
			"}"
		],
		"description": "divisors"
	},
	"prime_factors": {
		"scope": "cpp",
		"prefix": "prime_factors",
		"body": [
			"vector<ll> prime_factors(ll n)",
			"{",
			"    vector<ll> ret;",
			"    for (ll i = 2; i <= n / i; i++)",
			"    {",
			"        while (n % i == 0)",
			"        {",
			"            n /= i;",
			"            ret.push_back(i);",
			"        }",
			"    }",
			"    if (n > 1)",
			"        ret.push_back(n);",
			"    return ret;",
			"}"
		],
		"description": ""
	},
	"is_prime": {
		"scope": "cpp",
		"prefix": "is_prime",
		"body": [
			"bool is_prime(ll n)",
			"{",
			"    if (n < 2)",
			"        return 0;",
			"    for (ll i = 2; i <= n / i; i++)",
			"    {",
			"        if (n % i == 0)",
			"            return 0;",
			"    }",
			"    return 1;",
			"}"
		],
		"description": ""
	},
    "sieve":{
        "scope": "cpp",
	    "prefix": "sieve",
	    "body": [
           "namespace sieve {",
           "",
           "vector<int> Phi;",
           "vector<int> Primes;",
           "vector<bool> IsPrime;",
           "vector<int> NextPrime;",
           "vector<vector<int>> Divisors;",
           "vector<vector<int>> Factors;",
           "",
           "vector<bool> is_prime(int N) {",
           "    Primes.clear();",
           "    IsPrime.assign(N + 1, 1);",
           "    IsPrime[0] = IsPrime[1] = 0;",
           "    for (long long i = 2; i <= N; i++) {",
           "        if (IsPrime[i])",
           "            Primes.push_back(i);",
           "        for (auto it : Primes) {",
           "            if (i * it > N)",
           "                break;",
           "            IsPrime[i * it] = 0;",
           "            if (i % it == 0)",
           "                break;",
           "        }",
           "    }",
           "    return IsPrime;",
           "}",
           "",
           "vector<int> primes(int N) {",
           "    Primes.clear();",
           "    IsPrime.assign(N + 1, 1);",
           "    IsPrime[0] = IsPrime[1] = 0;",
           "    for (long long i = 2; i <= N; i++) {",
           "        if (IsPrime[i])",
           "            Primes.push_back(i);",
           "        for (auto it : Primes) {",
           "            if (i * it > N)",
           "                break;",
           "            IsPrime[i * it] = 0;",
           "            if (i % it == 0)",
           "                break;",
           "        }",
           "    }",
           "    return Primes;",
           "}",
           "",
           "vector<vector<int>> divs(int N) {",
           "    Divisors.assign(N + 1, {});",
           "    for (int i = 1; i <= N; i++) {",
           "        for (int j = i; j <= N; j += i)",
           "            Divisors[j].push_back(i);",
           "    }",
           "    return Divisors;",
           "}",
           "",
           "vector<vector<int>> factors(int N) {",
           "    Factors.assign(N + 1, {});",
           "    primes(N);",
           "    for (long long i = 1; i <= N; i++) {",
           "        for (auto it : Primes) {",
           "            if (i * it > N)",
           "                break;",
           "            Factors[i * it] = Factors[i];",
           "            Factors[i * it].push_back(it);",
           "        }",
           "    }",
           "    return Factors;",
           "}",
           "",
           "vector<int> phi(int N) {",
           "    Phi.assign(N + 1, 0);",
           "    iota(Phi.begin(), Phi.end(), 0);",
           "    for (int i = 1; i <= N; i++) {",
           "        for (int j = 2 * i; j <= N; j += i) {",
           "            Phi[j] -= Phi[i];",
           "        }",
           "    }",
           "    return Phi;",
           "}",
           "",
           "vector<int> next_prime(int N) {",
           "    is_prime(2 * N);",
           "    NextPrime.assign(2 * N + 1, 0);",
           "    int last = 1e9 + 7;",
           "    for (int i = 2 * N; ~i; i--) {",
           "        NextPrime[i] = last;",
           "        if (IsPrime[i])",
           "            last = i;",
           "    }",
           "    return NextPrime;",
           "}",
           "} // namespace sieve",
	    ],
        "description" : ""
    },
	"power": {
		"scope": "cpp",
		"prefix": "power",
		"body": [
			"ll power(ll n, ll p, ll MOD = 1000000007)",
			"{",
			"    if (!p)",
			"        return 1;",
			"    ll a = power(n, p / 2, MOD);",
			"    a = a * a % MOD;",
			"    if (p & 1)",
			"        return n % MOD * a % MOD;",
			"    return a;",
			"}",
		],
		"description": ""
	},
	"binarymx": {
		"scope": "cpp",
		"prefix": "binarymx",
		"body": [
			"auto valid = [&](ll mid)",
			"{",
			"};",
			"ll lo = $1, hi = $2, ans = -1;",
			"while (lo <= hi) // 111000",
			"{",
			"    ll mid = (lo + hi) / 2;",
			"    if (valid(mid))",
			"    {",
			"        lo = mid + 1;",
			"        ans = mid;",
			"    }",
			"    else",
			"    {",
			"        hi = mid - 1;",
			"    }",
			"}"
		],
		"description": ""
	},
	"binarymn": {
		"scope": "cpp",
		"prefix": "binarymn",
		"body": [
			"auto valid = [&](ll mid)",
			"{",
			"};",
			"ll lo = $1, hi = $2, ans = -1;",
			"while (lo <= hi) // 000111",
			"{",
			"    ll mid = (lo + hi) / 2;",
			"    if (valid(mid))",
			"    {",
			"        hi = mid - 1;",
			"        ans = mid;",
			"    }",
			"    else",
			"    {",
			"        lo = mid + 1;",
			"    }",
			"}"
		],
		"description": ""
	},
	"isoverflow": {
		"scope": "cpp",
		"prefix": "isoverflow",
		"body": [
			"bool isOverFlow(ll a, ll b)",
			"{",
			"    return log(a) + log(b) > log(3e18);",
			"}"
		],
		"description": ""
	},
	"unique": {
		"scope": "cpp",
		"prefix": "unique",
		"body": [
			"vector<ll> u(vector<ll> v)",
			"{",
			"    sort(v.begin(), v.end());",
			"    v.erase(unique(v.begin(), v.end()), v.end());",
			"    return v;",
			"}"
		],
		"description": ""
	},
	"int128": {
		"scope": "cpp",
		"prefix": "int128",
		"body": [
			"#define i128 __int128_t",
			"__int128 read()",
			"{",
			"    __int128 x = 0, f = 1;",
			"    char ch = getchar();",
			"    while (ch < '0' || ch > '9')",
			"    {",
			"        if (ch == '-')",
			"            f = -1;",
			"        ch = getchar();",
			"    }",
			"    while (ch >= '0' && ch <= '9')",
			"    {",
			"        x = x * 10 + ch - '0';",
			"        ch = getchar();",
			"    }",
			"    return x * f;",
			"}",
			"void print(__int128 x)",
			"{",
			"    if (x < 0)",
			"    {",
			"        putchar('-');",
			"        x = -x;",
			"    }",
			"    if (x > 9)",
			"        print(x / 10);",
			"    putchar(x % 10 + '0');",
			"}"
		],
		"description": ""
	},
	"npr": {
		"scope": "cpp",
		"prefix": "npr",
		"body": [
			"ll npr(int n, int r)",
			"{",
			"    if (r > n)",
			"        return 0;",
			"    ll p = 1, i = n - r + 1;",
			"    while (i <= n)",
			"        p *= i++;",
			"    return p;",
			"}"
		],
		"description": ""
	},
	"ncr": {
		"scope": "cpp",
		"prefix": "ncr",
		"body": [
			"ll ncr(ll n, ll r, ll MOD = 1000000007)",
			"{",
			"    if (n < r)",
			"        return 0;",
			"    if (r == 0)",
			"        return 1;",
			"    return (fac[n] * power(fac[r], MOD - 2, MOD) % MOD * power(fac[n - r], MOD - 2, MOD) % MOD) % MOD;",
			"}"
		],
		"description": ""
	},
	"inputline": {
		"scope": "cpp",
		"prefix": "inputline",
		"body": [
			"vector<ll> inputline()",
			"{",
			"    ll x;",
			"    string s;    ",
			"    vector<ll> ret;",
			"    getline(cin, s);",
			"    istringstream iss(s);",
			"    while (iss >> x)",
			"        ret.push_back(x);",
			"    return ret;",
			"}"
		],
		"description": ""
	},
	"ceil": {
		"scope": "cpp",
		"prefix": "ceil",
		"body": [
			"ll ceil(ll a, ll b)",
			"{",
			"    return a / b + (a % b ? 1 : 0);",
			"}"
		],
		"description": ""
	},
	"lis": {
		"scope": "cpp",
		"prefix": "lis",
		"body": [
			"ll lengthOfLIS(vector<ll> &nums)",
			"{",
			"    ll n = nums.size();",
			"    vector<ll> ans;",
			"    ans.push_back(nums[0]);",
			"    for (ll i = 1; i < n; i++)",
			"    {",
			"        if (nums[i] > ans.back())",
			"        {",
			"            ans.push_back(nums[i]);",
			"        }",
			"        else",
			"        {",
			"            ll low = lower_bound(ans.begin(), ans.end(), nums[i]) - ans.begin();",
			"            ans[low] = nums[i];",
			"        }",
			"    }",
			"    return ans.size();",
			"}"
		],
		"description": ""
	},
	"rev2d": {
		"scope": "cpp",
		"prefix": "rev2d",
		"body": [
			"vector<vector<$1>> rev(vector<vector<$1>> v)",
			"{",
			"    vector<vector<$1>> ret(v[0].size(), vector<$1>(v.size()));",
			"    for (ll i = 0; i < v[0].size(); i++)",
			"    {",
			"        for (ll j = 0; j < v.size(); j++)",
			"        {",
			"            ret[i][j] = v[j][i];",
			"        }",
			"    }",
			"    return ret;",
			"}"
		],
		"description": ""
	},
	"sq": {
		"scope": "cpp",
		"prefix": "sq",
		"body": [
			"ll sq(ll n)",
			"{",
			"    ll l = 0, r = 3e9;",
			"    while (l <= r)",
			"    {",
			"        ll mid = (l + r) / 2;",
			"        if (mid * mid <= n)",
			"            l = mid + 1;",
			"        else",
			"            r = mid - 1;",
			"    }",
			"    return r;",
			"}"
		],
		"description": ""
	},
	"kthbit": {
		"scope": "cpp",
		"prefix": "kthbit",
		"body": [
			"ll kthbit(ll n, ll k)",
			"{",
			"    return (n & (1 << (k - 1))) > 0;",
			"}"
		],
		"description": ""
	},
	"balanced": {
		"scope": "cpp",
		"prefix": "balanced",
		"body": [
			"bool balanced(string s)",
			"{",
			"    string t;",
			"    for (auto it : s)",
			"    {",
			"        if (t.empty())",
			"            t += it;",
			"        else if (t.back() == '(' && it == ')')",
			"            t.pop_back();",
			"        else",
			"            t += it;",
			"    }",
			"    return t.empty();",
			"}"
		],
		"description": ""
	},
	"fib": {
		"scope": "cpp",
		"prefix": "fib",
		"body": [
			"ll Nfib = 92;",
			"vector<ll> fib(Nfib + 1, 0);",
			"void solve_fib()",
			"{",
			"    fib[1] = 1;",
			"    for (ll i = 2; i <= Nfib; i++)",
			"        fib[i] = fib[i - 1] + fib[i - 2];",
			"}"
		],
		"description": ""
	},
	"fac": {
		"scope": "cpp",
		"prefix": "fac",
		"body": [
			"ll Nfac = 1e5;",
			"vector<ll> fac(Nfac + 1);",
			"void solve_fac()",
			"{",
			"    ll MOD = 1000000007;",
			"    fac[0] = 1;",
			"    for (ll i = 1; i <= Nfac; i++)",
			"        fac[i] = (fac[i - 1] * i) % MOD;",
			"}"
		],
		"description": ""
	},
	"pref": {
		"scope": "cpp",
		"prefix": "pref",
		"body": [
			"vector<ll> pref(vector<ll> v)",
			"{",
			"    auto ret = v;",
			"    partial_sum(ret.begin(), ret.end(), ret.begin());",
			"    return ret;",
			"}"
		],
		"description": ""
	},
	"mex": {
	"scope": "cpp",
	"prefix": "mex",
	"body": [
			"ll mex(set<ll> &s)",
			"{",
			"    ll cur = 0;",
			"    while (s.count(cur))",
			"        cur++;",
			"    return cur;",
			"}"
	],
	"description": ""
	},
	"fix": {
		"scope": "cpp",
		"prefix": "fix",
		"body": [
			"ll fix(ll n, ll mod)",
			"{",
			"    return ((n % mod) + mod) % mod;",
			"}"
		],
		"description": ""
	},
	"orderedset": {
	"scope": "cpp",
	"prefix": "orderedset",
	"body": [
			"#include <ext/pb_ds/assoc_container.hpp>",
			"#include <ext/pb_ds/tree_policy.hpp>",
			"using namespace __gnu_pbds;",
			"#define ordered_set tree<ll, null_type, less<>, rb_tree_tag, tree_order_statistics_node_update> // set",
			"typedef tree<int, null_type, less_equal<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_multiset;",
			"void myerase(ordered_set &t, int v)",
			"{",
			"    int rank = t.order_of_key(v);                     // Number of elements that are less than v in t",
			"    ordered_set::iterator it = t.find_by_order(rank); // Iterator that points to the (rank+1)th element in t",
			"    t.erase(it);",
			"}"
	],
	"description": ""
	},
    "segmenttree":{
        "scope": "cpp",
	    "prefix": "segmenttree",
	    "body": [
           "template <class T>",
           "class segment_tree",
           "{",
           "private:",
           "    struct node",
           "    {",
           "        ll skip = 0;",
           "        node() { skip = 1; }",
           "        ll op = 0, add = 0;",
           "        void laze(ll lx, ll rx) { *this = node(add); }",
           "        void reset() { op = 0, add = 0; }",
           "        void apply(ll val) { op = 1, add = val; }",
           "",
           "        node(T x)",
           "        {",
           "        }",
           "    };",
           "",
           "    node merge(node a, node b)",
           "    {",
           "        if (a.skip)",
           "            return b;",
           "        if (b.skip)",
           "            return a;",
           "        node ret;",
           "        ret.skip = 0;",
           "",
           "        return ret;",
           "    }",
           "",
           "    void propagate(ll x, ll lx, ll rx)",
           "    {",
           "        if (!seg[x].op)",
           "            return;",
           "        if (lx != rx)",
           "        {",
           "            seg[2 * x + 1].apply(seg[x].add);",
           "            seg[2 * x + 2].apply(seg[x].add);",
           "        }",
           "        seg[x].laze(lx, rx);",
           "        seg[x].reset();",
           "    }",
           "",
           "    ll size = 1;",
           "    vector<node> seg;",
           "    vector<T> buildseg;",
           "",
           "    void build(ll x, ll lx, ll rx)",
           "    {",
           "        if (lx == rx)",
           "        {",
           "            if (lx < buildseg.size())",
           "                seg[x] = node(buildseg[lx]);",
           "            return;",
           "        }",
           "        ll m = (lx + rx) / 2;",
           "        build(2 * x + 1, lx, m);",
           "        build(2 * x + 2, m + 1, rx);",
           "        seg[x] = merge(seg[2 * x + 1], seg[2 * x + 2]);",
           "    }",
           "",
           "    void update(ll l, ll r, T value, ll x, ll lx, ll rx)",
           "    {",
           "        propagate(x, lx, rx);",
           "        if (rx < l || r < lx)",
           "            return;",
           "        if (l <= lx && rx <= r)",
           "        {",
           "            seg[x].apply(value);",
           "            propagate(x, lx, rx);",
           "            return;",
           "        }",
           "        ll m = (lx + rx) / 2;",
           "        update(l, r, value, 2 * x + 1, lx, m);",
           "        update(l, r, value, 2 * x + 2, m + 1, rx);",
           "        seg[x] = merge(seg[2 * x + 1], seg[2 * x + 2]);",
           "    }",
           "",
           "    node query(ll l, ll r, ll x, ll lx, ll rx)",
           "    {",
           "        propagate(x, lx, rx);",
           "        if (rx < l || r < lx)",
           "            return node();",
           "        if (l <= lx && rx <= r)",
           "            return seg[x];",
           "        ll m = (lx + rx) / 2;",
           "        node s1 = query(l, r, 2 * x + 1, lx, m);",
           "        node s2 = query(l, r, 2 * x + 2, m + 1, rx);",
           "        return merge(s1, s2);",
           "    }",
           "",
           "public:",
           "    segment_tree(vector<T> a)",
           "    {",
           "        buildseg = a;",
           "        while (size < a.size())",
           "            size *= 2;",
           "        seg.assign(2 * size, node());",
           "        build(0, 0, size - 1);",
           "    }",
           "",
           "    void update(ll l, ll r, T value)",
           "    {",
           "        update(l, r, value, 0, 0, size - 1);",
           "    }",
           "",
           "    node query(ll l, ll r)",
           "    {",
           "        return query(l, r, 0, 0, size - 1);",
           "    }",
           "};",
	    ],
        "description" : ""
    },
	"MOs": {
	"scope": "cpp",
	"prefix": "MOs",
	"body": [
			"",
			"class MO // 1 index",
			"{",
			"private:",
			"    struct query",
			"    {",
			"        ll l, r, q_indx, b_indx;",
			"        query() {}",
			"        query(ll l, ll r, ll q_indx, ll b_indx)",
			"        {",
			"            this->l = l;",
			"            this->r = r;",
			"            this->q_indx = q_indx;",
			"            this->b_indx = b_indx;",
			"        }",
			"        bool operator<(query x)",
			"        {",
			"            if (b_indx != x.b_indx)",
			"                return b_indx < x.b_indx;",
			"            return r < x.r;",
			"        }",
			"    };",
			"",
			"    ll q = 0, SQ;",
			"    vector<ll> v;",
			"    vector<query> Q;",
			"",
			"    ll res = 0;",
			"    vector<ll> freq = vector<ll>(1e6 + 1, 0);",
			"    void add(ll ind)",
			"    {",
			"        if (!freq[v[ind]])",
			"            res++;",
			"        freq[v[ind]]++;",
			"    }",
			"    void remove(ll ind)",
			"    {",
			"        freq[v[ind]]--;",
			"        if (!freq[v[ind]])",
			"            res--;",
			"    }",
			"",
			"public:",
			"    MO(vector<ll> a)",
			"    {",
			"        v = a;",
			"        SQ = sqrt(a.size());",
			"    }",
			"",
			"    void add_query(ll l, ll r)",
			"    {",
			"        Q.push_back(query(--l, --r, q++, l / SQ));",
			"    }",
			"",
			"    void mo_process()",
			"    {",
			"        vector<ll> ans(q, 0);",
			"",
			"        sort(Q.begin(), Q.end());",
			"        ll r = 0, l = 1;",
			"        for (ll i = 0; i < q; i++)",
			"        {",
			"            while (r > Q[i].r)",
			"                remove(r--);",
			"            while (r < Q[i].r)",
			"                add(++r);",
			"            while (l > Q[i].l)",
			"                add(--l);",
			"            while (l < Q[i].l)",
			"                remove(l++);",
			"            ans[Q[i].q_indx] = res;",
			"        }",
			"",
			"        for (ll i = 0; i < q; i++)",
			"        {",
			"            cout << ans[i] << \"\\n \"[i == q - 1];",
			"        }",
			"    }",
			"};"
	],
	"description": ""
	},
	"sqrtdecomposition": {
	"scope": "cpp",
	"prefix": "sqrtdecomposition",
	"body": [
			"class SQblocks // 1 index",
			"{",
			"private:",
			"    ll SQ;",
			"    vector<ll> v;",
			"    vector<vector<ll>> block;",
			"",
			"    void sqdecompostion()",
			"    {",
			"        for (ll i = 0; i < v.size(); i++)",
			"        {",
			"            block[i / SQ].push_back(v[i]);",
			"        }",
			"        for (ll i = 0; i < SQ; i++)",
			"        {",
			"            sort(block[i].begin(), block[i].end());",
			"        }",
			"    }",
			"",
			"public:",
			"    SQblocks(vector<ll> a)",
			"    {",
			"        SQ = sqrt(a.size()) + 1;",
			"        v = a;",
			"        block.resize(SQ);",
			"        sqdecompostion();",
			"    }",
			"",
			"    void update(ll ind, ll val)",
			"    {",
			"        ind--;",
			"        ll it = lower_bound(block[ind / SQ].begin(), block[ind / SQ].end(), v[ind]) - block[ind / SQ].begin();",
			"        block[ind / SQ][it] = val;",
			"        sort(block[ind / SQ].begin(), block[ind / SQ].end());",
			"        v[ind] = val;",
			"    }",
			"",
			"    ll query(ll l, ll r)",
			"    {",
			"        l--, r--;",
			"        ll ret = LLONG_MAX;",
			"        while (l <= r)",
			"        {",
			"            if (l % SQ || r - l < SQ)",
			"            {",
			"                ret = min(ret, v[l++]);",
			"            }",
			"            else",
			"            {",
			"                ret = min(ret, block[l / SQ][0]);",
			"                l += SQ;",
			"            }",
			"        }",
			"        return ret;",
			"    }",
			"};"
	],
	"description": ""
	},
	"sparsetable": {
	"scope": "cpp",
	"prefix": "sparsetable",
	"body": [
			"class sparse_table // 1 index",
			"{",
			"private:",
			"    ll n;",
			"    vector<ll> v, LOG;",
			"    vector<vector<ll>> dp;",
			"",
			"    ll merge(ll a, ll b)",
			"    {",
			"        return max(a, b); // min , max , gcd , lcm , sum",
			"    }",
			"",
			"    void preCount()",
			"    {",
			"        for (ll i = 2; i <= n; i++)",
			"        {",
			"            LOG[i] = LOG[i >> 1] + 1;",
			"        }",
			"    }",
			"",
			"    void build()",
			"    {",
			"        for (ll i = 0; i < n; i++)",
			"        {",
			"            dp[i][0] = v[i];",
			"        }",
			"        for (ll mask = 1; (1 << mask) <= n; mask++)",
			"        {",
			"            for (ll i = 0; i + (1 << mask) <= n; i++)",
			"            {",
			"                dp[i][mask] = merge(dp[i][mask - 1], dp[i + (1 << (mask - 1))][mask - 1]);",
			"            }",
			"        }",
			"    }",
			"",
			"public:",
			"    sparse_table(vector<ll> v)",
			"    {",
			"        this->v = v;",
			"        n = v.size();",
			"        LOG.assign(n + 1, 0);",
			"        dp.assign(n + 1, vector<ll>(22, 0));",
			"        preCount();",
			"        build();",
			"    }",
			"",
			"    ll query(ll l, ll r)",
			"    {",
			"        l--, r--;",
			"        ll mask = LOG[r - l + 1];",
			"        return merge(dp[l][mask], dp[r - (1 << mask) + 1][mask]);",
			"    }",
			"};"
	],
	"description": ""
	},
	"iostream": {
	"scope": "cpp",
	"prefix": "iostream",
	"body": [
			"template <typename T = int>",
			"istream &operator>>(istream &in, vector<T> &v)",
			"{",
			"    for (auto &x : v)",
			"        in >> x;",
			"    return in;",
			"}",
			"template <typename T = int>",
			"ostream &operator<<(ostream &out, const vector<T> &v)",
			"{",
			"    for (const T &x : v)",
			"        out << x << ' ';",
			"    return out;",
			"}",
	],
	"description": ""
	},
	"mint": {
	"scope": "cpp",
	"prefix": "mint",
	"body": [
			"template <typename T>",
			"T inverse(T a, T m)",
			"{",
			"    T u = 0, v = 1;",
			"    while (a != 0)",
			"    {",
			"        T t = m / a;",
			"        m -= t * a;",
			"        swap(a, m);",
			"        u -= t * v;",
			"        swap(u, v);",
			"    }",
			"    assert(m == 1);",
			"    return u;",
			"}",
			"",
			"template <typename T>",
			"class Modular",
			"{",
			"public:",
			"    using Type = typename decay<decltype(T::value)>::type;",
			"",
			"    constexpr Modular() : value() {}",
			"    template <typename U>",
			"    Modular(const U &x)",
			"    {",
			"        value = normalize(x);",
			"    }",
			"",
			"    template <typename U>",
			"    static Type normalize(const U &x)",
			"    {",
			"        Type v;",
			"        if (-mod() <= x && x < mod())",
			"            v = static_cast<Type>(x);",
			"        else",
			"            v = static_cast<Type>(x % mod());",
			"        if (v < 0)",
			"            v += mod();",
			"        return v;",
			"    }",
			"",
			"    const Type &operator()() const { return value; }",
			"    template <typename U>",
			"    explicit operator U() const { return static_cast<U>(value); }",
			"    constexpr static Type mod() { return T::value; }",
			"",
			"    Modular &operator+=(const Modular &other)",
			"    {",
			"        if ((value += other.value) >= mod())",
			"            value -= mod();",
			"        return *this;",
			"    }",
			"    Modular &operator-=(const Modular &other)",
			"    {",
			"        if ((value -= other.value) < 0)",
			"            value += mod();",
			"        return *this;",
			"    }",
			"    template <typename U>",
			"    Modular &operator+=(const U &other) { return *this += Modular(other); }",
			"    template <typename U>",
			"    Modular &operator-=(const U &other) { return *this -= Modular(other); }",
			"    Modular &operator++() { return *this += 1; }",
			"    Modular &operator--() { return *this -= 1; }",
			"    Modular operator++(int)",
			"    {",
			"        Modular result(*this);",
			"        *this += 1;",
			"        return result;",
			"    }",
			"    Modular operator--(int)",
			"    {",
			"        Modular result(*this);",
			"        *this -= 1;",
			"        return result;",
			"    }",
			"    Modular operator-() const { return Modular(-value); }",
			"",
			"    template <typename U = T>",
			"    typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type &operator*=(const Modular &rhs)",
			"    {",
			"#ifdef _WIN32",
			"        uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);",
			"        uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;",
			"        asm(",
			"            \"divl %4; \\n\\t\"",
			"            : \"=a\"(d), \"=d\"(m)",
			"            : \"d\"(xh), \"a\"(xl), \"r\"(mod()));",
			"        value = m;",
			"#else",
			"        value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));",
			"#endif",
			"        return *this;",
			"    }",
			"    template <typename U = T>",
			"    typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type &operator*=(const Modular &rhs)",
			"    {",
			"        long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());",
			"        value = normalize(value * rhs.value - q * mod());",
			"        return *this;",
			"    }",
			"    template <typename U = T>",
			"    typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type &operator*=(const Modular &rhs)",
			"    {",
			"        value = normalize(value * rhs.value);",
			"        return *this;",
			"    }",
			"",
			"    Modular &operator/=(const Modular &other) { return *this *= Modular(inverse(other.value, mod())); }",
			"",
			"    friend const Type &abs(const Modular &x) { return x.value; }",
			"",
			"    template <typename U>",
			"    friend bool operator==(const Modular<U> &lhs, const Modular<U> &rhs);",
			"",
			"    template <typename U>",
			"    friend bool operator<(const Modular<U> &lhs, const Modular<U> &rhs);",
			"",
			"    template <typename V, typename U>",
			"    friend V &operator>>(V &stream, Modular<U> &number);",
			"",
			"private:",
			"    Type value;",
			"};",
			"",
			"template <typename T>",
			"bool operator==(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value == rhs.value; }",
			"template <typename T, typename U>",
			"bool operator==(const Modular<T> &lhs, U rhs) { return lhs == Modular<T>(rhs); }",
			"template <typename T, typename U>",
			"bool operator==(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) == rhs; }",
			"",
			"template <typename T>",
			"bool operator!=(const Modular<T> &lhs, const Modular<T> &rhs) { return !(lhs == rhs); }",
			"template <typename T, typename U>",
			"bool operator!=(const Modular<T> &lhs, U rhs) { return !(lhs == rhs); }",
			"template <typename T, typename U>",
			"bool operator!=(U lhs, const Modular<T> &rhs) { return !(lhs == rhs); }",
			"",
			"template <typename T>",
			"bool operator<(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value < rhs.value; }",
			"",
			"template <typename T>",
			"Modular<T> operator+(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }",
			"template <typename T, typename U>",
			"Modular<T> operator+(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) += rhs; }",
			"template <typename T, typename U>",
			"Modular<T> operator+(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }",
			"",
			"template <typename T>",
			"Modular<T> operator-(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }",
			"template <typename T, typename U>",
			"Modular<T> operator-(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) -= rhs; }",
			"template <typename T, typename U>",
			"Modular<T> operator-(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }",
			"",
			"template <typename T>",
			"Modular<T> operator*(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }",
			"template <typename T, typename U>",
			"Modular<T> operator*(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) *= rhs; }",
			"template <typename T, typename U>",
			"Modular<T> operator*(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }",
			"",
			"template <typename T>",
			"Modular<T> operator/(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }",
			"template <typename T, typename U>",
			"Modular<T> operator/(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) /= rhs; }",
			"template <typename T, typename U>",
			"Modular<T> operator/(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }",
			"",
			"template <typename T, typename U>",
			"Modular<T> power(const Modular<T> &a, const U &b)",
			"{",
			"    assert(b >= 0);",
			"    Modular<T> x = a, res = 1;",
			"    U p = b;",
			"    while (p > 0)",
			"    {",
			"        if (p & 1)",
			"            res *= x;",
			"        x *= x;",
			"        p >>= 1;",
			"    }",
			"    return res;",
			"}",
			"",
			"template <typename T>",
			"bool IsZero(const Modular<T> &number)",
			"{",
			"    return number() == 0;",
			"}",
			"",
			"template <typename T>",
			"string to_string(const Modular<T> &number)",
			"{",
			"    return to_string(number());",
			"}",
			"",
			"// U == std::ostream? but done this way because of fastoutput",
			"template <typename U, typename T>",
			"U &operator<<(U &stream, const Modular<T> &number)",
			"{",
			"    return stream << number();",
			"}",
			"",
			"// U == std::istream? but done this way because of fastinput",
			"template <typename U, typename T>",
			"U &operator>>(U &stream, Modular<T> &number)",
			"{",
			"    typename common_type<typename Modular<T>::Type, long long>::type x;",
			"    stream >> x;",
			"    number.value = Modular<T>::normalize(x);",
			"    return stream;",
			"}",
			"",
			"/*",
			"using ModType = int;",
			"",
			"struct VarMod { static ModType value; };",
			"ModType VarMod::value;",
			"ModType& md = VarMod::value;",
			"using Mint = Modular<VarMod>;",
			"*/",
			"",
			"constexpr int md = 998244353;",
			"using Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;",
			"",
			"/*vector<Mint> fact(1, 1);",
			"vector<Mint> inv_fact(1, 1);",
			"",
			"Mint C(int n, int k) {",
			"  if (k < 0 || k > n) {",
			"    return 0;",
			"  }",
			"  while ((int) fact.size() < n + 1) {",
			"    fact.push_back(fact.back() * (int) fact.size());",
			"    inv_fact.push_back(1 / fact.back());",
			"  }",
			"  return fact[n] * inv_fact[k] * inv_fact[n - k];",
			"}*/",


	],
	"description": ""
	},
	"log": {
	"scope": "cpp",
	"prefix": "log",
	"body": [
			"ll log(ll a, ll b)",
			"{",
			"    ll ret = 0, x = 1;",
			"    while (x * a <= b)",
			"    {",
			"        x *= a;",
			"        ret++;",
			"    }",
			"    return ret;",
			"}",
	],
	"description": ""
	},
    "compress":{
        "scope": "cpp",
	    "prefix": "compress",
	    "body": [
           "vector<ll> compress(vector<ll> &v)",
           "{",
           "    ll n = v.size();",
           "    vector<pair<ll, ll>> p;",
           "    for (ll i = 0; i < n; i++)",
           "    {",
           "        p.push_back({v[i], i});",
           "    }",
           "    sort(p.begin(), p.end());",
           "",
           "    vector<ll> real(n);",
           "    ll last = p[0].first, nxt = 0;",
           "    for (auto [F, S] : p)",
           "    {",
           "        if (last < F)",
           "            nxt++;",
           "        last = F;",
           "        real[nxt] = F;",
           "        v[S] = nxt;",
           "    }",
           "    return real;",
           "}",
	    ],
        "description" : ""
    },
    "graph":{
        "scope": "cpp",
	    "prefix": "graph",
	    "body": [
           "class graph",
           "{",
           "private:",
           "    ll N;",
           "    vector<ll> vis;",
           "    vector<ll> comp;",
           "    vector<ll> is_cyclic;",
           "    vector<ll> num_of_edges;",
           "    vector<vector<pair<ll, ll>>> g;",
           "",
           "    void do_dfs(ll node)",
           "    {",
           "        if (vis[node])",
           "            return;",
           "        vis[node] = 1;",
           "        for (auto it : g[node])",
           "        {",
           "            if (!vis[it.first])",
           "            {",
           "                do_dfs(it.first);",
           "            }",
           "        }",
           "    }",
           "",
           "    void bfs(vector<ll> parent, ll dis, vector<ll> &mn_dis)",
           "    {",
           "        if (parent.empty())",
           "            return;",
           "        for (auto it : parent)",
           "            mn_dis[it] = dis;",
           "        vector<ll> child;",
           "        for (auto i : parent)",
           "        {",
           "            vis[i] = 1;",
           "            for (auto j : g[i])",
           "            {",
           "                if (!vis[j.first])",
           "                {",
           "                    child.push_back(j.first);",
           "                    vis[j.first] = 1;",
           "                }",
           "            }",
           "        }",
           "        bfs(child, dis + 1, mn_dis);",
           "    }",
           "",
           "public:",
           "    graph(ll n)",
           "    {",
           "        N = n + 1;",
           "        g.resize(N);",
           "        num_of_edges.assign(N, 0);",
           "    }",
           "    ~graph() {}",
           "",
           "    void add_edge(ll u, ll v, ll cost = 0)",
           "    {",
           "        num_of_edges[u]++;",
           "        g[u].push_back({v, cost});",
           "    }",
           "",
           "    void dfs(ll node)",
           "    {",
           "        vis.assign(N, 0);",
           "        do_dfs(node);",
           "    }",
           "",
           "    vector<ll> components()",
           "    {",
           "        ll key = 0;",
           "        vis.assign(N, 0);",
           "        comp.assign(N, 0);",
           "        auto check = [&](auto self, ll node)",
           "        {",
           "            if (vis[node])",
           "                return;",
           "            comp[node] = key;",
           "            vis[node] = 1;",
           "            for (auto it : g[node])",
           "            {",
           "                if (!vis[it.first])",
           "                {",
           "                    self(self, it.first);",
           "                }",
           "            }",
           "        };",
           "        for (ll i = 0; i < N; i++)",
           "        {",
           "            if (!vis[i])",
           "            {",
           "                check(check, i);",
           "                key++;",
           "            }",
           "        }",
           "        return comp;",
           "    }",
           "",
           "    vector<ll> is_on_cycle()",
           "    {",
           "        auto check = [&](auto self, ll node)",
           "        {",
           "            if (vis[node] || is_cyclic[node] != 1)",
           "                return;",
           "            is_cyclic[node]--;",
           "            vis[node] = 1;",
           "            for (auto it : g[node])",
           "            {",
           "                if (!vis[it.first])",
           "                {",
           "                    is_cyclic[it.first]--;",
           "                    self(self, it.first);",
           "                }",
           "            }",
           "        };",
           "        vis.assign(N, 0);",
           "        is_cyclic = num_of_edges;",
           "        for (ll i = 1; i < N; i++)",
           "            check(check, i);",
           "        return is_cyclic;",
           "    }",
           "",
           "    vector<ll> bfs(ll node)",
           "    {",
           "        vector<ll> dis(N, 1e18);",
           "        vis.assign(N, 0);",
           "        bfs({node}, 0, dis);",
           "        return dis;",
           "    }",
           "",
           "    vector<ll> dijkstra(ll start)",
           "    {",
           "        vis.assign(N, 0);",
           "        priority_queue<pair<ll, ll>> pq;",
           "        vector<ll> cheapest_path(N);",
           "        pq.push({0, start});",
           "        while (pq.size())",
           "        {",
           "            ll cost = pq.top().first, node = pq.top().second;",
           "            pq.pop();",
           "            if (vis[node])",
           "                continue;",
           "            vis[node] = 1;",
           "            cheapest_path[node] = -cost;",
           "            for (auto [a, b] : g[node])",
           "            {",
           "                if (!vis[a])",
           "                {",
           "                    pq.push({-b + cost, a});",
           "                }",
           "            }",
           "        }",
           "        return cheapest_path;",
           "    }",
           "",
           "    vector<ll> dsu_parent;",
           "    ll get_parent(ll node)",
           "    {",
           "        if (dsu_parent.empty())",
           "        {",
           "            dsu_parent.assign(N, 0);",
           "            iota(dsu_parent.begin(), dsu_parent.end(), 0);",
           "        }",
           "        if (node == dsu_parent[node])",
           "            return node;",
           "        return dsu_parent[node] = get_parent(dsu_parent[node]);",
           "    }",
           "",
           "    bool same_set(ll u, ll v)",
           "    {",
           "        return get_parent(u) == get_parent(v);",
           "    }",
           "",
           "    void unite(ll u, ll v)",
           "    {",
           "        u = get_parent(u);",
           "        v = get_parent(v);",
           "        dsu_parent[u] = v;",
           "    }",
           "",
           "    void solve()",
           "    {",
           "    }",
           "};",
	    ],
        "description" : ""
    },
    "matrixmult":{
        "scope": "cpp",
	    "prefix": "matrixmult",
	    "body": [
           "vector<vector<ll>> mult(vector<vector<ll>> a, vector<vector<ll>> b)",
           "{",
           "    assert(a[0].size() == b.size());",
           "    vector<vector<ll>> ret(a.size(), vector<ll>(b[0].size(), 0));",
           "    for (ll i = 0; i < a.size(); i++)",
           "    {",
           "        for (ll j = 0; j < b[0].size(); j++)",
           "        {",
           "            for (ll o = 0; o < b.size(); o++)",
           "                ret[i][j] += (a[i][o] * b[o][j]);",
           "        }",
           "    }",
           "    return ret;",
           "}",
	    ],
        "description" : ""
    },
    "kadane":{
        "scope": "cpp",
	    "prefix": "kadane",
	    "body": [
           "ll kadane(vector<ll> v, ll &l, ll &r)",
           "{",
           "    ll sum = 0, temp = 0, start = 0;",
           "    for (ll i = 0; i < v.size(); i++)",
           "    {",
           "        temp += v[i];",
           "        if (sum < temp)",
           "        {",
           "            sum = temp;",
           "            l = start;",
           "            r = i;",
           "        }",
           "        if (temp < 0)",
           "        {",
           "            temp = 0;",
           "            start = i + 1;",
           "        }",
           "    }",
           "    return sum;",
           "}",
	    ],
        "description" : ""
    },
    "proxy":{
        "scope": "cpp",
	    "prefix": "proxy",
	    "body": [
           "class proxy",
           "{",
           "public:",
           "    ll ind;",
           "    segment_tree *st;",
           "    proxy(segment_tree *a = 0, ll i = 0)",
           "    {",
           "        st = a;",
           "        ind = i;",
           "    }",
           "    proxy &operator=(ll val)",
           "    {",
           "        st->update(ind, ind, val);",
           "        st->buildseg[ind] = val;",
           "        return *this;",
           "    }",
           "    operator T()",
           "    {",
           "        return st->buildseg[ind];",
           "    }",
           "};",
           "",
           "proxy operator[](ll ind)",
           "{",
           "    return proxy(this, ind);",
           "}",
	    ],
        "description" : ""
    },
    "phi":{
        "scope": "cpp",
	    "prefix": "phi",
	    "body": [
           "ll phi(ll n)// n * (1 - 1/p)",
           "{",
           "    ll ret = n;",
           "    for (ll i = 2; i <= n / i; i++)",
           "    {",
           "        if (n % i == 0)",
           "        {",
           "            while (n % i == 0)",
           "                n /= i;",
           "            ret -= ret / i;",
           "        }",
           "    }",
           "    if (n > 1)",
           "        ret -= ret / n;",
           "    return ret;",
           "}",
	    ],
        "description" : ""
    },
    "rope":{
        "scope": "cpp",
	    "prefix": "rope",
	    "body": [
           "#include <ext/rope>",
           "using namespace __gnu_cxx;",
           "rope<int> x;",
	    ],
        "description" : ""
    },
    "mem":{
        "scope": "cpp",
	    "prefix": "mem",
	    "body": [
           "memset(dp, -1, sizeof dp);",
	    ],
        "description" : ""
    },
    "point":{
        "scope": "cpp",
	    "prefix": "point",
	    "body": [
           "template <typename T>",
           "struct TPoint",
           "{",
           "    T x;",
           "    T y;",
           "    int id;",
           "",
           "    TPoint() : x(0), y(0), id(-1) {}",
           "    TPoint(const T &x_, const T &y_) : x(x_), y(y_), id(-1) {}",
           "    TPoint(const T &x_, const T &y_, int id_) : x(x_), y(y_), id(id_) {}",
           "",
           "    static constexpr T eps = static_cast<T>(1e-9);",
           "",
           "    inline TPoint operator+(const TPoint &rhs) const { return TPoint(x + rhs.x, y + rhs.y); }",
           "    inline TPoint operator-(const TPoint &rhs) const { return TPoint(x - rhs.x, y - rhs.y); }",
           "    inline TPoint operator*(const T &rhs) const { return TPoint(x * rhs, y * rhs); }",
           "    inline TPoint operator/(const T &rhs) const { return TPoint(x / rhs, y / rhs); }",
           "",
           "    friend T smul(const TPoint &a, const TPoint &b)",
           "    {",
           "        return a.x * b.x + a.y * b.y;",
           "    }",
           "",
           "    friend T vmul(const TPoint &a, const TPoint &b)",
           "    {",
           "        return a.x * b.y - a.y * b.x;",
           "    }",
           "",
           "    inline T abs2() const",
           "    {",
           "        return x * x + y * y;",
           "    }",
           "",
           "    inline bool operator<(const TPoint &rhs) const",
           "    {",
           "        return (y < rhs.y || (y == rhs.y && x < rhs.x));",
           "    }",
           "",
           "    inline bool is_upper() const",
           "    {",
           "        return (y > eps || (abs(y) <= eps && x > eps));",
           "    }",
           "",
           "    inline int cmp_polar(const TPoint &rhs) const",
           "    {",
           "        assert(abs(x) > eps || abs(y) > eps);",
           "        assert(abs(rhs.x) > eps || abs(rhs.y) > eps);",
           "        bool a = is_upper();",
           "        bool b = rhs.is_upper();",
           "        if (a != b)",
           "        {",
           "            return (a ? -1 : 1);",
           "        }",
           "        long long v = x * rhs.y - y * rhs.x;",
           "        return (v > eps ? -1 : (v < -eps ? 1 : 0));",
           "    }",
           "};",
           "",
           "using Point = TPoint<long long>;",
           "// using Point = TPoint<long double>;",
           "",
           "template <typename T>",
           "string to_string(const TPoint<T> &p)",
           "{",
           "    return \"(\" + to_string(p.x) + \", \" + to_string(p.y) + \")\";",
           "}",
	    ],
        "description" : ""
    },
    "file":{
        "scope": "cpp",
	    "prefix": "file",
	    "body": [
           "#ifdef ONLINE_JUDGE",
           "    freopen(\"input.txt\", \"r\", stdin);",
           "    freopen(\"output.txt\", \"w\", stdout);",
           "#endif",
	    ],
        "description" : ""
    },
    "stack":{
        "scope": "cpp",
	    "prefix": "stack",
	    "body": [
           "class Stack",
           "{",
           "private:",
           "    int items[mxSize];",
           "    int top;",
           "",
           "public:",
           "    Stack()",
           "    {",
           "        top = -1;",
           "    }",
           "    ~Stack() {}",
           "",
           "    void push(int x)",
           "    {",
           "        if (full())",
           "        {",
           "            cout << \"Stack is overflow\";",
           "            return;",
           "        }",
           "        top++;",
           "        items[top] = x;",
           "    }",
           "",
           "    int pop()",
           "    {",
           "        if (empty())",
           "        {",
           "            cout << \"Stack is underflow\";",
           "            return -1;",
           "        }",
           "        int item = items[top];",
           "        top--;",
           "        return item;",
           "    }",
           "",
           "    int empty()",
           "    {",
           "        return (top == -1);",
           "    }",
           "",
           "    int full()",
           "    {",
           "        return (top == mxSize - 1);",
           "    }",
           "",
           "    void display()",
           "    {",
           "        for (int i = 0; i <= top; i++)",
           "            cout << items[i] << \" \";",
           "    }",
           "};",
	    ],
        "description" : ""
    },
    "postfixeval":{
        "scope": "cpp",
	    "prefix": "postfixeval",
	    "body": [
           "int eval_postfix(string str)",
           "{",
           "    Stack s;",
           "    double a, b, val;",
           "    for (int i = 0; i < str.length(); i++)",
           "    {",
           "        if (isdigit(str[i]))",
           "            s.push(str[i] - '0');",
           "        else",
           "        {",
           "            b = s.pop();",
           "            a = s.pop();",
           "            if (str[i] == '+')",
           "                val = a + b;",
           "            else if (str[i] == '-')",
           "                val = a - b;",
           "            else if (str[i] == '*')",
           "                val = a * b;",
           "            else if (str[i] == '/')",
           "                val = a / b;",
           "            else if (str[i] == '^')",
           "                val = pow(a, b);",
           "            s.push(val);",
           "        }",
           "    }",
           "    return s.pop();",
           "}",
	    ],
        "description" : ""
    },
    "intopost":{
        "scope": "cpp",
	    "prefix": "intopost",
	    "body": [
           "int precedence(char x)",
           "{",
           "    if (x == '(')",
           "        return 1;",
           "    else if (x == ')')",
           "        return 2;",
           "    else if (x == '+' || x == '-')",
           "        return 3;",
           "    else if (x == '*' || x == '/' || x == '%')",
           "        return 4;",
           "    else if (x == '^')",
           "        return 5;",
           "    else ",
           "        return 0;",
           "}",
           "",
           "// infix -> postfix",
           "void InfixToPostfix(string infix)",
           "{",
           "    char ch;",
           "    string postfix;",
           "",
           "    Stack s;",
           "    s.push('(');",
           "    infix += ')';",
           "    for (int i = 0; i < infix.size(); i++)",
           "    {",
           "        int x = precedence(infix[i]);",
           "",
           "        if (x == 1)",
           "        {",
           "            s.push(infix[i]);",
           "        }",
           "        else if (x == 2)",
           "        {",
           "            ch = s.pop();",
           "            while (ch != '(')",
           "            {",
           "                postfix += ch;",
           "                ch = s.pop();",
           "            }",
           "        }",
           "        else if (x == 3)",
           "        {",
           "            ch = s.pop();",
           "            while (precedence(ch) >= 3)",
           "            {",
           "                postfix += ch;",
           "                ch = s.pop();",
           "            }",
           "            s.push(ch);",
           "            s.push(infix[i]);",
           "        }",
           "        else if (x == 4)",
           "        {",
           "            ch = s.pop();",
           "            while (precedence(ch) >= 4)",
           "            {",
           "                postfix += ch;",
           "                ch = s.pop();",
           "            }",
           "            s.push(ch);",
           "            s.push(infix[i]);",
           "        }",
           "        else if (x == 5)",
           "        {",
           "            ch = s.pop();",
           "            while (precedence(ch) == 5)",
           "            {",
           "                postfix += ch;",
           "                ch = s.pop();",
           "            }",
           "            s.push(ch);",
           "            s.push(infix[i]);",
           "        }",
           "        else",
           "        {",
           "            postfix += infix[i];",
           "        }",
           "    }",
           "    cout << \"the postfix is \" << postfix;",
           "}",
	    ],
        "description" : ""
    },
    "queue":{
        "scope": "cpp",
	    "prefix": "queue",
	    "body": [
           "class queue",
           "{",
           "private:",
           "    int items[mxSize];",
           "    int front, rear;",
           "",
           "public:",
           "    queue()",
           "    {",
           "        front = -1;",
           "        rear = -1;",
           "    }",
           "",
           "    void enqueue(int item)",
           "    {",
           "        if (rear == mxSize - 1)",
           "        {",
           "            cout << \"Queue is Overflow\" << endl;",
           "            return;",
           "        }",
           "        if (front == -1)",
           "            front = 0;",
           "        rear++;",
           "        items[rear] = item;",
           "    }",
           "",
           "    int dequeue()",
           "    {",
           "        int item;",
           "        if (front == -1 && rear == -1)",
           "        {",
           "            cout << \"Queue is underflow\" << endl;",
           "            return -1;",
           "        }",
           "        else if (front == rear)",
           "        {",
           "            item = items[front];",
           "            front = rear = -1;",
           "        }",
           "        else",
           "        {",
           "            item = items[front];",
           "            front++;",
           "        }",
           "        return item;",
           "    }",
           "",
           "    void display()",
           "    {",
           "        cout << \"the current items of the queue are:\" << endl;",
           "        for (int i = front; i <= rear; i++)",
           "            cout << items[i] << \" \";",
           "    }",
           "};",
	    ],
        "description" : ""
    },
    "cirqueue":{
        "scope": "cpp",
	    "prefix": "cirqueue",
	    "body": [
           "class Circular_Queue",
           "{",
           "private:",
           "    int item[mxSize];",
           "    int front;",
           "    int rear;",
           "",
           "public:",
           "    Circular_Queue()",
           "    {",
           "        front = -1;",
           "        rear = -1;",
           "    }",
           "",
           "    void enqueue(int data)",
           "    {",
           "        if (front == (rear + 1) % mxSize)",
           "        {",
           "            cout << \"over flow\n\";",
           "            return;",
           "        }",
           "        if (front == -1)",
           "            front = 0;",
           "        rear = (rear + 1) % mxSize;",
           "        item[rear] = data;",
           "    }",
           "",
           "    int dequeue()",
           "    {",
           "        int temp;",
           "        if (front == -1 && rear == -1)",
           "        {",
           "            cout << \"under flow\n\";",
           "            return -1;",
           "        }",
           "        if (front == rear)",
           "        {",
           "            temp = item[front];",
           "            front = rear = -1;",
           "        }",
           "        else",
           "        {",
           "            temp = item[front];",
           "            front = (front + 1) % mxSize;",
           "        }",
           "        return temp;",
           "    }",
           "",
           "    void display()",
           "    {",
           "        if (front == -1 & rear == -1)",
           "        {",
           "            cout << \"underflow\n\";",
           "            return;",
           "        }",
           "        for (int i = front; i != rear; i = (i + 1) % mxSize)",
           "            cout << item[i] << \" \";",
           "    }",
           "};",
	    ],
        "description" : ""
    },
    "linkedList":{
        "scope": "cpp",
	    "prefix": "linkedList",
	    "body": [
           "",
           "struct node",
           "{",
           "    int data;",
           "    node *next;",
           "};",
           "class linkedList",
           "{",
           "private:",
           "    node *start;",
           "    node *last;",
           "",
           "public:",
           "    linkedList()",
           "    {",
           "        start = NULL;",
           "        last = NULL;",
           "    }",
           "",
           "    void addFirst(int item)",
           "    {",
           "        node *n = new node;",
           "        n->data = item;",
           "        n->next = NULL;",
           "",
           "        if (start == NULL)",
           "        {",
           "            start = n;",
           "            last = n;",
           "        }",
           "        else",
           "        {",
           "            n->next = start;",
           "            start = n;",
           "        }",
           "    }",
           "",
           "    void addLast(int item)",
           "    {",
           "        node *n = new node;",
           "        n->data = item;",
           "        n->next = NULL;",
           "",
           "        if (start == NULL)",
           "        {",
           "            start = n;",
           "            last = n;",
           "            return;",
           "        }",
           "        else",
           "        {",
           "            node *curr = start;",
           "            while (curr->next != NULL)",
           "            {",
           "                curr = curr->next;",
           "            }",
           "            curr->next = n;",
           "            last = n;",
           "        }",
           "    }",
           "",
           "    void addPosition(int position, int item)",
           "    {",
           "        if (position == 1)",
           "        {",
           "            addFirst(item);",
           "            return;",
           "        }",
           "        position--;",
           "        if (start == NULL)",
           "        {",
           "            cout << \"Invalid position.\\n\";",
           "            return;",
           "        }",
           "        node *n = new node;",
           "        n->next = NULL;",
           "        n->data = item;",
           "        node *curr = start;",
           "        for (int i = 0; i < position - 1; i++)",
           "        {",
           "            curr = curr->next;",
           "            if (curr == NULL)",
           "            {",
           "                cout << \"Invalid Position.\\n\";",
           "                return;",
           "            }",
           "        }",
           "        n->next = curr->next;",
           "        curr->next = n;",
           "        if (n->next == NULL)",
           "        {",
           "            last = n;",
           "        }",
           "    }",
           "",
           "    void removeFirst()",
           "    {",
           "        if (start == NULL)",
           "        {",
           "            cout << \"Empty list.\\n\";",
           "            return;",
           "        }",
           "        else",
           "        {",
           "            if (start->next == NULL)",
           "            {",
           "                delete start;",
           "                start = NULL;",
           "                last = NULL;",
           "            }",
           "            else",
           "            {",
           "                node *temp = start;",
           "                start = start->next;",
           "                delete temp;",
           "            }",
           "        }",
           "    }",
           "",
           "    void removeLast()",
           "    {",
           "        if (start == NULL)",
           "        {",
           "            cout << \"Empty list.\\n\";",
           "            return;",
           "        }",
           "        else",
           "        {",
           "            if (start->next == NULL)",
           "            {",
           "                delete start;",
           "                start = NULL;",
           "                last = NULL;",
           "            }",
           "            else",
           "            {",
           "                node *curr = start;",
           "                node *temp = last;",
           "                while (curr->next != last)",
           "                {",
           "                    curr = curr->next;",
           "                }",
           "                curr->next = NULL;",
           "                last = curr;",
           "                delete temp;",
           "            }",
           "        }",
           "    }",
           "",
           "    int search(int item)",
           "    {",
           "        node *curr = start;",
           "        int pos = 0;",
           "",
           "        while (curr != NULL && curr->data != item)",
           "        {",
           "            curr = curr->next;",
           "            pos++;",
           "        }",
           "",
           "        if (curr == NULL)",
           "        {",
           "            pos = -1;",
           "        }",
           "        return pos;",
           "    }",
           "",
           "    void removeData(int item)",
           "    {",
           "        if (start == NULL)",
           "        {",
           "            cout << \"List is empty.\\n\";",
           "            return;",
           "        }",
           "        else if (start->data == item)",
           "        {",
           "            removeFirst();",
           "            return;",
           "        }",
           "        node *curr = start;",
           "        while (curr->next != NULL && curr->data != item)",
           "        {",
           "            curr = curr->next;",
           "        }",
           "        if (curr->next == NULL)",
           "        {",
           "            cout << \"Data is not found.\\n\";",
           "            return;",
           "        }",
           "        node *n = curr->next;",
           "        curr->next = n->next;",
           "        delete n;",
           "    }",
           "",
           "    void display()",
           "    {",
           "        node *p = start;",
           "        cout << \"The list is: \";",
           "        while (p != NULL)",
           "        {",
           "            cout << p->data << \" | \";",
           "            p = p->next;",
           "        }",
           "        cout << \"\\n\";",
           "    }",
           "};",
	    ],
        "description" : ""
    }
}
/*

,
"": {
	"scope": "cpp",
	"prefix": "",
	"body": [

	],
	"description": ""
}

*/