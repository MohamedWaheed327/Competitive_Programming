{
	// Place your global snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"all": {
		"scope": "cpp",
		"prefix": "all",
		"body": [
			"$1.begin(), $1.end()$2"
		],
		"description": "all"
	},
	"sort": {
		"scope": "cpp",
		"prefix": "sort",
		"body": [
			"sort($1.begin(), $1.end());$2"
		],
		"description": "sort"
	},
	"reverse": {
		"scope": "cpp",
		"prefix": "reverse",
		"body": [
			"reverse($1.begin(), $1.end());$2"
		],
		"description": "reverse"
	},
	"rsort": {
		"scope": "cpp",
		"prefix": "rsort",
		"body": [
			"sort($1.rbegin(), $1.rend());$2"
		],
		"description": "rsort"
	},
	"vin": {
		"scope": "cpp",
		"prefix": "vin",
		"body": [
			"ll n;",
			"cin >> n;",
			"",
			"vector<ll> v(n);",
			"for (ll i = 0; i < n; i++) {",
			"	cin >> v[i];",
			"}"
		],
		"description": "vin"
	},
	"out": {
		"scope": "cpp",
		"prefix": "out",
		"body": [
			"for (auto it : $1) {",
			"	cout << it << \" \";",
			"}",
			"cout << '\\n';"
		],
		"description": "out"
	},
	"2din": {
		"scope": "cpp",
		"prefix": "2din",
		"body": [
			"ll n, m;",
			"cin >> n >> m;",
			"",
			"vector<vector<$1>> v(n + 2, vector<$1>(m + 2));",
			"for (ll i = 1; i <= n; i++) {",
			"\tfor (ll j = 1; j <= m; j++) {",
			"\t\tcin >> v[i][j];",
			"\t}",
			"}"
		],
		"description": "2din"
	},
	"2dout": {
		"scope": "cpp",
		"prefix": "2dout",
		"body": [
			"for (ll i = 1; i <= n; i++) {",
			"\tfor (ll j = 1; j <= m; j++) {",
			"\t\tcout << v[i][j] << \" \";",
			"\t}",
			"\tcout << \"\\n\";",
			"}"
		],
		"description": "2dout"
	},
	"stin": {
		"scope": "cpp",
		"prefix": "stin",
		"body": [
			"ll n;",
			"string s;",
			"cin >> n >> s;",
			"for (ll i = 0; i < s.size(); i++) {",
			"}"
		],
		"description": "stin"
	},
	"yes": {
		"scope": "cpp",
		"prefix": "yes",
		"body": [
			"#define yes cout << \"YES\";",
			"#define no cout << \"NO\";"
		],
		"description": "yes"
	},
	"mod1": {
		"scope": "cpp",
		"prefix": "mod1",
		"body": [
			"ll mod = 1e9 + 7;"
		],
		"description": "mod"
	},
	"mod2": {
		"scope": "cpp",
		"prefix": "mod2",
		"body": [
			"ll mod = (119 << 23) + 1;"
		],
		"description": "mod"
	},
	"divisors": {
		"scope": "cpp",
		"prefix": "divisors",
		"body": [
			"vector<ll> divisors(ll n) {",
			"    vector<ll> ret;",
			"    for (ll i = 1; i <= n / i; i++) {",
			"        if (n % i == 0) {",
			"            ret.push_back(i);",
			"            if (i * i != n)",
			"                ret.push_back(n / i);",
			"        }",
			"    }",
			"    return ret;",
			"}"
		],
		"description": "divisors"
	},
	"prime_factors": {
		"scope": "cpp",
		"prefix": "prime_factors",
		"body": [
			"vector<ll> prime_factors(ll n) {",
			"    vector<ll> ret;",
			"    for (ll i = 2; i <= n / i; i++) {",
			"        while (n % i == 0) {",
			"            n /= i;",
			"            ret.push_back(i);",
			"        }",
			"    }",
			"    if (n > 1) {",
			"        ret.push_back(n);",
			"    }",
			"    return ret;",
			"}"
		],
		"description": ""
	},
	"is_prime": {
		"scope": "cpp",
		"prefix": "is_prime",
		"body": [
			"bool is_prime(ll n) {",
			"    if (n < 2)",
			"        return 0;",
			"    for (ll i = 2; i <= n / i; i++) {",
			"        if (n % i == 0)",
			"            return 0;",
			"    }",
			"    return 1;",
			"}"
		],
		"description": ""
	},
	"power": {
		"scope": "cpp",
		"prefix": "power",
		"body": [
			"ll power(ll n, ll p, ll MOD = 1e9 + 7) {",
			"    if (!p)",
			"        return 1;",
			"    ll a = power(n, p / 2, MOD);",
			"    a = a * a % MOD;",
			"    if (p & 1)",
			"        return n % MOD * a % MOD;",
			"    return a;",
			"}",
		],
		"description": ""
	},
	"binarymx": {
		"scope": "cpp",
		"prefix": "binarymx",
		"body": [
			"auto valid = [&](ll mid) {",
			"};",
            "",
			"ll lo = $1, hi = $2, ans = -1;",
			"while (lo <= hi) { // 111000",
			"    ll mid = (lo + hi) / 2;",
			"    if (valid(mid)) {",
			"        lo = mid + 1;",
			"        ans = mid;",
			"    }",
			"    else {",
			"        hi = mid - 1;",
			"    }",
			"}"
		],
		"description": ""
	},
	"binarymn": {
		"scope": "cpp",
		"prefix": "binarymn",
		"body": [
			"auto valid = [&](ll mid) {",
			"};",
            "",
			"ll lo = $1, hi = $2, ans = -1;",
			"while (lo <= hi) { // 000111",
			"    ll mid = (lo + hi) / 2;",
			"    if (valid(mid)) {",
			"        hi = mid - 1;",
			"        ans = mid;",
			"    }",
			"    else {",
			"        lo = mid + 1;",
			"    }",
			"}"
		],
		"description": ""
	},
	"isoverflow": {
		"scope": "cpp",
		"prefix": "isoverflow",
		"body": [
			"bool isOverFlow(ll a, ll b) {",
			"    return log(a) + log(b) > log(3e18);",
			"}"
		],
		"description": ""
	},
	"npr": {
		"scope": "cpp",
		"prefix": "npr",
		"body": [
			"ll npr(int n, int r)",
			"{",
			"    if (r > n)",
			"        return 0;",
			"    ll p = 1, i = n - r + 1;",
			"    while (i <= n)",
			"        p *= i++;",
			"    return p;",
			"}"
		],
		"description": ""
	},
	"ncr": {
		"scope": "cpp",
		"prefix": "ncr",
		"body": [
			"ll ncr(ll n, ll r, ll MOD = 1000000007)",
			"{",
			"    if (n < r)",
			"        return 0;",
			"    if (r == 0)",
			"        return 1;",
			"    return (fac[n] * power(fac[r], MOD - 2, MOD) % MOD * power(fac[n - r], MOD - 2, MOD) % MOD) % MOD;",
			"}"
		],
		"description": ""
	},
	"inputline": {
		"scope": "cpp",
		"prefix": "inputline",
		"body": [
			"vector<ll> inputline()",
			"{",
			"    ll x;",
			"    string s;    ",
			"    vector<ll> ret;",
			"    getline(cin, s);",
			"    istringstream iss(s);",
			"    while (iss >> x)",
			"        ret.push_back(x);",
			"    return ret;",
			"}"
		],
		"description": ""
	},
	"ceil": {
		"scope": "cpp",
		"prefix": "ceil",
		"body": [
			"ll ceil(ll a, ll b) {",
			"    return a / b + !!(a % b);",
			"}"
		],
		"description": ""
	},
	"lis": {
		"scope": "cpp",
		"prefix": "lis",
		"body": [
			"ll lengthOfLIS(vector<ll> &nums) {",
			"    ll n = nums.size();",
			"    vector<ll> ans;",
			"    ans.push_back(nums[0]);",
			"    for (ll i = 1; i < n; i++) {",
			"        if (nums[i] > ans.back()) {",
			"            ans.push_back(nums[i]);",
			"        }",
			"        else {",
			"            ll low = lower_bound(ans.begin(), ans.end(), nums[i]) - ans.begin();",
			"            ans[low] = nums[i];",
			"        }",
			"    }",
			"    return ans.size();",
			"}"
		],
		"description": ""
	},
	"rev2d": {
		"scope": "cpp",
		"prefix": "rev2d",
		"body": [
			"vector<vector<$1>> rev(vector<vector<$1>> v)",
			"{",
			"    vector<vector<$1>> ret(v[0].size(), vector<$1>(v.size()));",
			"    for (ll i = 0; i < v[0].size(); i++)",
			"    {",
			"        for (ll j = 0; j < v.size(); j++)",
			"        {",
			"            ret[i][j] = v[j][i];",
			"        }",
			"    }",
			"    return ret;",
			"}"
		],
		"description": ""
	},
	"sq": {
		"scope": "cpp",
		"prefix": "sq",
		"body": [
			"ll sq(ll n)",
			"{",
			"    ll l = 0, r = 3e9;",
			"    while (l <= r)",
			"    {",
			"        ll mid = (l + r) / 2;",
			"        if (mid * mid <= n)",
			"            l = mid + 1;",
			"        else",
			"            r = mid - 1;",
			"    }",
			"    return r;",
			"}"
		],
		"description": ""
	},
	"kthbit": {
		"scope": "cpp",
		"prefix": "kthbit",
		"body": [
			"ll kthbit(ll n, ll k) {",
			"    return !!(n & (1 << k));",
			"}"
		],
		"description": ""
	},
	"balanced": {
		"scope": "cpp",
		"prefix": "balanced",
		"body": [
			"bool balanced(string s)",
			"{",
			"    string t;",
			"    for (auto it : s)",
			"    {",
			"        if (t.empty())",
			"            t += it;",
			"        else if (t.back() == '(' && it == ')')",
			"            t.pop_back();",
			"        else",
			"            t += it;",
			"    }",
			"    return t.empty();",
			"}"
		],
		"description": ""
	},
	"fib": {
		"scope": "cpp",
		"prefix": "fib",
		"body": [
			"ll Nfib = 92;",
			"vector<ll> fib(Nfib + 1, 0);",
			"void solve_fib()",
			"{",
			"    fib[1] = 1;",
			"    for (ll i = 2; i <= Nfib; i++)",
			"        fib[i] = fib[i - 1] + fib[i - 2];",
			"}"
		],
		"description": ""
	},
	"fac": {
		"scope": "cpp",
		"prefix": "fac",
		"body": [
			"ll Nfac = 1e5;",
			"vector<ll> fac(Nfac + 1);",
			"void solve_fac()",
			"{",
			"    ll MOD = 1000000007;",
			"    fac[0] = 1;",
			"    for (ll i = 1; i <= Nfac; i++)",
			"        fac[i] = (fac[i - 1] * i) % MOD;",
			"}"
		],
		"description": ""
	},
	"pref": {
		"scope": "cpp",
		"prefix": "pref",
		"body": [
			"vector<ll> pref(vector<ll> v)",
			"{",
			"    auto ret = v;",
			"    partial_sum(ret.begin(), ret.end(), ret.begin());",
			"    return ret;",
			"}"
		],
		"description": ""
	},
	"mex": {
	"scope": "cpp",
	"prefix": "mex",
	"body": [
			"ll mex(set<ll> &s)",
			"{",
			"    ll cur = 0;",
			"    while (s.count(cur))",
			"        cur++;",
			"    return cur;",
			"}"
	],
	"description": ""
	},
	"fix": {
		"scope": "cpp",
		"prefix": "fix",
		"body": [
			"ll fix(ll n, ll mod)",
			"{",
			"    return ((n % mod) + mod) % mod;",
			"}"
		],
		"description": ""
	},
	"iostream": {
	"scope": "cpp",
	"prefix": "iostream",
	"body": [
			"template <typename T>",
			"istream &operator>>(istream &in, vector<T> &v) {",
			"    for (auto &x : v)",
			"        in >> x;",
			"    return in;",
			"}",
			"template <typename T>",
			"ostream &operator<<(ostream &out, const vector<T> &v) {",
			"    for (const T &x : v)",
			"        out << x << ' ';",
			"    return out;",
			"}",
	],
	"description": ""
	},
	"mint": {
	"scope": "cpp",
	"prefix": "mint",
	"body": [
			"template <typename T>",
			"T inverse(T a, T m)",
			"{",
			"    T u = 0, v = 1;",
			"    while (a != 0)",
			"    {",
			"        T t = m / a;",
			"        m -= t * a;",
			"        swap(a, m);",
			"        u -= t * v;",
			"        swap(u, v);",
			"    }",
			"    assert(m == 1);",
			"    return u;",
			"}",
			"",
			"template <typename T>",
			"class Modular",
			"{",
			"public:",
			"    using Type = typename decay<decltype(T::value)>::type;",
			"",
			"    constexpr Modular() : value() {}",
			"    template <typename U>",
			"    Modular(const U &x)",
			"    {",
			"        value = normalize(x);",
			"    }",
			"",
			"    template <typename U>",
			"    static Type normalize(const U &x)",
			"    {",
			"        Type v;",
			"        if (-mod() <= x && x < mod())",
			"            v = static_cast<Type>(x);",
			"        else",
			"            v = static_cast<Type>(x % mod());",
			"        if (v < 0)",
			"            v += mod();",
			"        return v;",
			"    }",
			"",
			"    const Type &operator()() const { return value; }",
			"    template <typename U>",
			"    explicit operator U() const { return static_cast<U>(value); }",
			"    constexpr static Type mod() { return T::value; }",
			"",
			"    Modular &operator+=(const Modular &other)",
			"    {",
			"        if ((value += other.value) >= mod())",
			"            value -= mod();",
			"        return *this;",
			"    }",
			"    Modular &operator-=(const Modular &other)",
			"    {",
			"        if ((value -= other.value) < 0)",
			"            value += mod();",
			"        return *this;",
			"    }",
			"    template <typename U>",
			"    Modular &operator+=(const U &other) { return *this += Modular(other); }",
			"    template <typename U>",
			"    Modular &operator-=(const U &other) { return *this -= Modular(other); }",
			"    Modular &operator++() { return *this += 1; }",
			"    Modular &operator--() { return *this -= 1; }",
			"    Modular operator++(int)",
			"    {",
			"        Modular result(*this);",
			"        *this += 1;",
			"        return result;",
			"    }",
			"    Modular operator--(int)",
			"    {",
			"        Modular result(*this);",
			"        *this -= 1;",
			"        return result;",
			"    }",
			"    Modular operator-() const { return Modular(-value); }",
			"",
			"    template <typename U = T>",
			"    typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type &operator*=(const Modular &rhs)",
			"    {",
			"#ifdef _WIN32",
			"        uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);",
			"        uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;",
			"        asm(",
			"            \"divl %4; \\n\\t\"",
			"            : \"=a\"(d), \"=d\"(m)",
			"            : \"d\"(xh), \"a\"(xl), \"r\"(mod()));",
			"        value = m;",
			"#else",
			"        value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));",
			"#endif",
			"        return *this;",
			"    }",
			"    template <typename U = T>",
			"    typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type &operator*=(const Modular &rhs)",
			"    {",
			"        long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());",
			"        value = normalize(value * rhs.value - q * mod());",
			"        return *this;",
			"    }",
			"    template <typename U = T>",
			"    typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type &operator*=(const Modular &rhs)",
			"    {",
			"        value = normalize(value * rhs.value);",
			"        return *this;",
			"    }",
			"",
			"    Modular &operator/=(const Modular &other) { return *this *= Modular(inverse(other.value, mod())); }",
			"",
			"    friend const Type &abs(const Modular &x) { return x.value; }",
			"",
			"    template <typename U>",
			"    friend bool operator==(const Modular<U> &lhs, const Modular<U> &rhs);",
			"",
			"    template <typename U>",
			"    friend bool operator<(const Modular<U> &lhs, const Modular<U> &rhs);",
			"",
			"    template <typename V, typename U>",
			"    friend V &operator>>(V &stream, Modular<U> &number);",
			"",
			"private:",
			"    Type value;",
			"};",
			"",
			"template <typename T>",
			"bool operator==(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value == rhs.value; }",
			"template <typename T, typename U>",
			"bool operator==(const Modular<T> &lhs, U rhs) { return lhs == Modular<T>(rhs); }",
			"template <typename T, typename U>",
			"bool operator==(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) == rhs; }",
			"",
			"template <typename T>",
			"bool operator!=(const Modular<T> &lhs, const Modular<T> &rhs) { return !(lhs == rhs); }",
			"template <typename T, typename U>",
			"bool operator!=(const Modular<T> &lhs, U rhs) { return !(lhs == rhs); }",
			"template <typename T, typename U>",
			"bool operator!=(U lhs, const Modular<T> &rhs) { return !(lhs == rhs); }",
			"",
			"template <typename T>",
			"bool operator<(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value < rhs.value; }",
			"",
			"template <typename T>",
			"Modular<T> operator+(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }",
			"template <typename T, typename U>",
			"Modular<T> operator+(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) += rhs; }",
			"template <typename T, typename U>",
			"Modular<T> operator+(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }",
			"",
			"template <typename T>",
			"Modular<T> operator-(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }",
			"template <typename T, typename U>",
			"Modular<T> operator-(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) -= rhs; }",
			"template <typename T, typename U>",
			"Modular<T> operator-(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }",
			"",
			"template <typename T>",
			"Modular<T> operator*(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }",
			"template <typename T, typename U>",
			"Modular<T> operator*(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) *= rhs; }",
			"template <typename T, typename U>",
			"Modular<T> operator*(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }",
			"",
			"template <typename T>",
			"Modular<T> operator/(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }",
			"template <typename T, typename U>",
			"Modular<T> operator/(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) /= rhs; }",
			"template <typename T, typename U>",
			"Modular<T> operator/(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }",
			"",
			"template <typename T, typename U>",
			"Modular<T> power(const Modular<T> &a, const U &b)",
			"{",
			"    assert(b >= 0);",
			"    Modular<T> x = a, res = 1;",
			"    U p = b;",
			"    while (p > 0)",
			"    {",
			"        if (p & 1)",
			"            res *= x;",
			"        x *= x;",
			"        p >>= 1;",
			"    }",
			"    return res;",
			"}",
			"",
			"template <typename T>",
			"bool IsZero(const Modular<T> &number)",
			"{",
			"    return number() == 0;",
			"}",
			"",
			"template <typename T>",
			"string to_string(const Modular<T> &number)",
			"{",
			"    return to_string(number());",
			"}",
			"",
			"// U == std::ostream? but done this way because of fastoutput",
			"template <typename U, typename T>",
			"U &operator<<(U &stream, const Modular<T> &number)",
			"{",
			"    return stream << number();",
			"}",
			"",
			"// U == std::istream? but done this way because of fastinput",
			"template <typename U, typename T>",
			"U &operator>>(U &stream, Modular<T> &number)",
			"{",
			"    typename common_type<typename Modular<T>::Type, long long>::type x;",
			"    stream >> x;",
			"    number.value = Modular<T>::normalize(x);",
			"    return stream;",
			"}",
			"",
			"/*",
			"using ModType = int;",
			"",
			"struct VarMod { static ModType value; };",
			"ModType VarMod::value;",
			"ModType& md = VarMod::value;",
			"using Mint = Modular<VarMod>;",
			"*/",
			"",
			"constexpr int md = 998244353;",
			"using Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;",
			"",
			"/*vector<Mint> fact(1, 1);",
			"vector<Mint> inv_fact(1, 1);",
			"",
			"Mint C(int n, int k) {",
			"  if (k < 0 || k > n) {",
			"    return 0;",
			"  }",
			"  while ((int) fact.size() < n + 1) {",
			"    fact.push_back(fact.back() * (int) fact.size());",
			"    inv_fact.push_back(1 / fact.back());",
			"  }",
			"  return fact[n] * inv_fact[k] * inv_fact[n - k];",
			"}*/",


	],
	"description": ""
	},
	"log": {
	"scope": "cpp",
	"prefix": "log",
	"body": [
			"ll log(ll a, ll b)",
			"{",
			"    ll ret = 0, x = 1;",
			"    while (x * a <= b)",
			"    {",
			"        x *= a;",
			"        ret++;",
			"    }",
			"    return ret;",
			"}",
	],
	"description": ""
	},
    "compress":{
        "scope": "cpp",
	    "prefix": "compress",
	    "body": [
           "vector<ll> compress(vector<ll> &v)",
           "{",
           "    ll n = v.size();",
           "    vector<pair<ll, ll>> p;",
           "    for (ll i = 0; i < n; i++)",
           "    {",
           "        p.push_back({v[i], i});",
           "    }",
           "    sort(p.begin(), p.end());",
           "",
           "    vector<ll> real(n);",
           "    ll last = p[0].first, nxt = 0;",
           "    for (auto [F, S] : p)",
           "    {",
           "        if (last < F)",
           "            nxt++;",
           "        last = F;",
           "        real[nxt] = F;",
           "        v[S] = nxt;",
           "    }",
           "    return real;",
           "}",
	    ],
        "description" : ""
    },
    "matrixmult":{
        "scope": "cpp",
	    "prefix": "matrixmult",
	    "body": [
           "vector<vector<ll>> mult(const vector<vector<ll>> &a, const vector<vector<ll>> &b) {",
           "    assert(a[0].size() == b.size());",
           "    vector<vector<ll>> ret(a.size(), vector<ll>(b[0].size(), 0));",
           "    for (ll i = 0; i < a.size(); i++) {",
           "        for (ll j = 0; j < b[0].size(); j++) {",
           "            for (ll o = 0; o < b.size(); o++)",
           "                ret[i][j] += (a[i][o] * b[o][j]);",
           "        }",
           "    }",
           "    return ret;",
           "}",
	    ],
        "description" : ""
    },
    "kadane":{
        "scope": "cpp",
	    "prefix": "kadane",
	    "body": [
           "ll kadane(vector<ll> v, ll &l, ll &r)",
           "{",
           "    ll sum = 0, temp = 0, start = 0;",
           "    for (ll i = 0; i < v.size(); i++)",
           "    {",
           "        temp += v[i];",
           "        if (sum < temp)",
           "        {",
           "            sum = temp;",
           "            l = start;",
           "            r = i;",
           "        }",
           "        if (temp < 0)",
           "        {",
           "            temp = 0;",
           "            start = i + 1;",
           "        }",
           "    }",
           "    return sum;",
           "}",
	    ],
        "description" : ""
    },
    "phi":{
        "scope": "cpp",
	    "prefix": "phi",
	    "body": [
           "ll phi(ll n)// n * (1 - 1/p)",
           "{",
           "    ll ret = n;",
           "    for (ll i = 2; i <= n / i; i++)",
           "    {",
           "        if (n % i == 0)",
           "        {",
           "            while (n % i == 0)",
           "                n /= i;",
           "            ret -= ret / i;",
           "        }",
           "    }",
           "    if (n > 1)",
           "        ret -= ret / n;",
           "    return ret;",
           "}",
	    ],
        "description" : ""
    },
    "rope":{
        "scope": "cpp",
	    "prefix": "rope",
	    "body": [
           "#include <ext/rope>",
           "using namespace __gnu_cxx;",
           "rope<int> x;",
	    ],
        "description" : ""
    },
    "mem":{
        "scope": "cpp",
	    "prefix": "mem",
	    "body": [
           "memset(dp, -1, sizeof dp);",
	    ],
        "description" : ""
    },
    "point":{
        "scope": "cpp",
	    "prefix": "point",
	    "body": [
           "template <typename T>",
           "struct TPoint",
           "{",
           "    T x;",
           "    T y;",
           "    int id;",
           "",
           "    TPoint() : x(0), y(0), id(-1) {}",
           "    TPoint(const T &x_, const T &y_) : x(x_), y(y_), id(-1) {}",
           "    TPoint(const T &x_, const T &y_, int id_) : x(x_), y(y_), id(id_) {}",
           "",
           "    static constexpr T eps = static_cast<T>(1e-9);",
           "",
           "    inline TPoint operator+(const TPoint &rhs) const { return TPoint(x + rhs.x, y + rhs.y); }",
           "    inline TPoint operator-(const TPoint &rhs) const { return TPoint(x - rhs.x, y - rhs.y); }",
           "    inline TPoint operator*(const T &rhs) const { return TPoint(x * rhs, y * rhs); }",
           "    inline TPoint operator/(const T &rhs) const { return TPoint(x / rhs, y / rhs); }",
           "",
           "    friend T smul(const TPoint &a, const TPoint &b)",
           "    {",
           "        return a.x * b.x + a.y * b.y;",
           "    }",
           "",
           "    friend T vmul(const TPoint &a, const TPoint &b)",
           "    {",
           "        return a.x * b.y - a.y * b.x;",
           "    }",
           "",
           "    inline T abs2() const",
           "    {",
           "        return x * x + y * y;",
           "    }",
           "",
           "    inline bool operator<(const TPoint &rhs) const",
           "    {",
           "        return (y < rhs.y || (y == rhs.y && x < rhs.x));",
           "    }",
           "",
           "    inline bool is_upper() const",
           "    {",
           "        return (y > eps || (abs(y) <= eps && x > eps));",
           "    }",
           "",
           "    inline int cmp_polar(const TPoint &rhs) const",
           "    {",
           "        assert(abs(x) > eps || abs(y) > eps);",
           "        assert(abs(rhs.x) > eps || abs(rhs.y) > eps);",
           "        bool a = is_upper();",
           "        bool b = rhs.is_upper();",
           "        if (a != b)",
           "        {",
           "            return (a ? -1 : 1);",
           "        }",
           "        long long v = x * rhs.y - y * rhs.x;",
           "        return (v > eps ? -1 : (v < -eps ? 1 : 0));",
           "    }",
           "};",
           "",
           "using Point = TPoint<long long>;",
           "// using Point = TPoint<long double>;",
           "",
           "template <typename T>",
           "string to_string(const TPoint<T> &p)",
           "{",
           "    return \"(\" + to_string(p.x) + \", \" + to_string(p.y) + \")\";",
           "}",
	    ],
        "description" : ""
    },
    "file":{
        "scope": "cpp",
	    "prefix": "file",
	    "body": [
           "#ifdef ONLINE_JUDGE",
           "    freopen(\"input.txt\", \"r\", stdin);",
           "    freopen(\"output.txt\", \"w\", stdout);",
           "#endif",
	    ],
        "description" : ""
    },
    "linkedList":{
        "scope": "cpp",
	    "prefix": "linkedList",
	    "body": [
           "",
           "struct node",
           "{",
           "    int data;",
           "    node *next;",
           "};",
           "class linkedList",
           "{",
           "private:",
           "    node *start;",
           "    node *last;",
           "",
           "public:",
           "    linkedList()",
           "    {",
           "        start = NULL;",
           "        last = NULL;",
           "    }",
           "",
           "    void addFirst(int item)",
           "    {",
           "        node *n = new node;",
           "        n->data = item;",
           "        n->next = NULL;",
           "",
           "        if (start == NULL)",
           "        {",
           "            start = n;",
           "            last = n;",
           "        }",
           "        else",
           "        {",
           "            n->next = start;",
           "            start = n;",
           "        }",
           "    }",
           "",
           "    void addLast(int item)",
           "    {",
           "        node *n = new node;",
           "        n->data = item;",
           "        n->next = NULL;",
           "",
           "        if (start == NULL)",
           "        {",
           "            start = n;",
           "            last = n;",
           "            return;",
           "        }",
           "        else",
           "        {",
           "            node *curr = start;",
           "            while (curr->next != NULL)",
           "            {",
           "                curr = curr->next;",
           "            }",
           "            curr->next = n;",
           "            last = n;",
           "        }",
           "    }",
           "",
           "    void addPosition(int position, int item)",
           "    {",
           "        if (position == 1)",
           "        {",
           "            addFirst(item);",
           "            return;",
           "        }",
           "        position--;",
           "        if (start == NULL)",
           "        {",
           "            cout << \"Invalid position.\\n\";",
           "            return;",
           "        }",
           "        node *n = new node;",
           "        n->next = NULL;",
           "        n->data = item;",
           "        node *curr = start;",
           "        for (int i = 0; i < position - 1; i++)",
           "        {",
           "            curr = curr->next;",
           "            if (curr == NULL)",
           "            {",
           "                cout << \"Invalid Position.\\n\";",
           "                return;",
           "            }",
           "        }",
           "        n->next = curr->next;",
           "        curr->next = n;",
           "        if (n->next == NULL)",
           "        {",
           "            last = n;",
           "        }",
           "    }",
           "",
           "    void removeFirst()",
           "    {",
           "        if (start == NULL)",
           "        {",
           "            cout << \"Empty list.\\n\";",
           "            return;",
           "        }",
           "        else",
           "        {",
           "            if (start->next == NULL)",
           "            {",
           "                delete start;",
           "                start = NULL;",
           "                last = NULL;",
           "            }",
           "            else",
           "            {",
           "                node *temp = start;",
           "                start = start->next;",
           "                delete temp;",
           "            }",
           "        }",
           "    }",
           "",
           "    void removeLast()",
           "    {",
           "        if (start == NULL)",
           "        {",
           "            cout << \"Empty list.\\n\";",
           "            return;",
           "        }",
           "        else",
           "        {",
           "            if (start->next == NULL)",
           "            {",
           "                delete start;",
           "                start = NULL;",
           "                last = NULL;",
           "            }",
           "            else",
           "            {",
           "                node *curr = start;",
           "                node *temp = last;",
           "                while (curr->next != last)",
           "                {",
           "                    curr = curr->next;",
           "                }",
           "                curr->next = NULL;",
           "                last = curr;",
           "                delete temp;",
           "            }",
           "        }",
           "    }",
           "",
           "    int search(int item)",
           "    {",
           "        node *curr = start;",
           "        int pos = 0;",
           "",
           "        while (curr != NULL && curr->data != item)",
           "        {",
           "            curr = curr->next;",
           "            pos++;",
           "        }",
           "",
           "        if (curr == NULL)",
           "        {",
           "            pos = -1;",
           "        }",
           "        return pos;",
           "    }",
           "",
           "    void removeData(int item)",
           "    {",
           "        if (start == NULL)",
           "        {",
           "            cout << \"List is empty.\\n\";",
           "            return;",
           "        }",
           "        else if (start->data == item)",
           "        {",
           "            removeFirst();",
           "            return;",
           "        }",
           "        node *curr = start;",
           "        while (curr->next != NULL && curr->data != item)",
           "        {",
           "            curr = curr->next;",
           "        }",
           "        if (curr->next == NULL)",
           "        {",
           "            cout << \"Data is not found.\\n\";",
           "            return;",
           "        }",
           "        node *n = curr->next;",
           "        curr->next = n->next;",
           "        delete n;",
           "    }",
           "",
           "    void display()",
           "    {",
           "        node *p = start;",
           "        cout << \"The list is: \";",
           "        while (p != NULL)",
           "        {",
           "            cout << p->data << \" | \";",
           "            p = p->next;",
           "        }",
           "        cout << \"\\n\";",
           "    }",
           "};",
	    ],
        "description" : ""
    },
    "for":{
        "scope": "cpp",
	    "prefix": "for",
	    "body": [
           "for (ll ${1:i} = ${2:0}; ${1:i} < ${3:n}; ++${1:i}) {",
           "    $4",
           "}",
	    ],
        "description" : ""
    }
}
/*

,
"": {
	"scope": "cpp",
	"prefix": "",
	"body": [

	],
	"description": ""
}

*/
